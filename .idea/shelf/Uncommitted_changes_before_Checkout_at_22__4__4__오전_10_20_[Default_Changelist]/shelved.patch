Index: app/src/main/java/com/silverback/carman/fragments/BoardPagerFragment.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.silverback.carman.fragments;\n\n\nimport static com.silverback.carman.BoardActivity.AUTOCLUB;\nimport static com.silverback.carman.BoardActivity.PAGINATION;\n\nimport android.animation.Animator;\nimport android.animation.AnimatorListenerAdapter;\nimport android.animation.ObjectAnimator;\nimport android.content.Context;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.text.TextUtils;\nimport android.view.LayoutInflater;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.animation.AccelerateDecelerateInterpolator;\nimport android.widget.ImageView;\nimport android.widget.ProgressBar;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport androidx.annotation.NonNull;\nimport androidx.core.content.ContextCompat;\nimport androidx.fragment.app.Fragment;\nimport androidx.lifecycle.ViewModelProvider;\nimport androidx.recyclerview.widget.DefaultItemAnimator;\nimport androidx.recyclerview.widget.LinearLayoutManager;\nimport androidx.recyclerview.widget.RecyclerView;\n\nimport com.google.android.material.floatingactionbutton.FloatingActionButton;\nimport com.google.firebase.firestore.CollectionReference;\nimport com.google.firebase.firestore.DocumentReference;\nimport com.google.firebase.firestore.DocumentSnapshot;\nimport com.google.firebase.firestore.FieldValue;\nimport com.google.firebase.firestore.FirebaseFirestore;\nimport com.google.firebase.firestore.ListenerRegistration;\nimport com.google.firebase.firestore.MetadataChanges;\nimport com.google.firebase.firestore.QuerySnapshot;\nimport com.google.firebase.firestore.SetOptions;\nimport com.google.firebase.firestore.Source;\nimport com.silverback.carman.BoardActivity;\nimport com.silverback.carman.R;\nimport com.silverback.carman.adapters.BoardPostingAdapter;\nimport com.silverback.carman.databinding.FragmentBoardPagerBinding;\nimport com.silverback.carman.logs.LoggingHelper;\nimport com.silverback.carman.logs.LoggingHelperFactory;\nimport com.silverback.carman.utils.ApplyImageResourceUtil;\nimport com.silverback.carman.utils.Constants;\nimport com.silverback.carman.utils.CustomPostingObject;\nimport com.silverback.carman.utils.QueryPostPaginationUtil;\nimport com.silverback.carman.utils.RecyclerDividerUtil;\nimport com.silverback.carman.viewmodels.FragmentSharedModel;\n\nimport java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Objects;\n\n/*\n * The viewpager statically creates this fragment using BoardPagerAdapter, which has the custom\n * recyclerview to show the posting board by category.\n *\n * QueryPostPaginationUtil is a util class that performs query and pagination based on orderby() and\n * limit(). This class is made of the initial, next, and last query for pagination, listening to\n * scrolling of the recyclerview. MVVM-based architecture is provided in the board package just for\n * referernce.\n *\n * Instead of using SnapshotListener for realtime update, which seems difficult to handle cache data\n * in the viewpager fragments, the util simply reads posts using get() and updates are made by requerying\n * posts notified by the viewmodel(FragmentSharedModel). Comments in BoardReadFragment, however,\n * applies SnapshotListener.\n *\n * Refactoring based on MVVM to improve the query performance should be made. At the moment, related\n * codes are commented.\n */\npublic class BoardPagerFragment extends Fragment implements\n        QueryPostPaginationUtil.OnQueryPaginationCallback,\n        //BoardReadFragment.OnDialogDismissListener,\n        //QueryClubPostingUtil.OnPaginationListener,\n        BoardPostingAdapter.OnRecyclerItemClickListener {\n\n    // Logging\n    private static final LoggingHelper log = LoggingHelperFactory.create(BoardPagerFragment.class);\n\n    // Objects\n    //private List<MultiTypeItem> multiTypeItemList;\n    private List<DocumentSnapshot> postingList;\n\n    private FirebaseFirestore firestore;\n    private ListenerRegistration regListener;\n    private CollectionReference colRef;\n    private Source source;\n    //private PostingBoardViewModel postingModel;\n    //private PostingBoardRepository postRepo;\n    //private QueryClubPostingUtil clubRepo;\n    //private ListenerRegistration listenerRegistration;\n    private QueryPostPaginationUtil queryPagingUtil;\n    private BoardPostingAdapter postingAdapter;\n\n    private ArrayList<String> autoFilter;\n    private SimpleDateFormat sdf;\n    private ApplyImageResourceUtil imgutil;\n    // UIs\n    private FragmentBoardPagerBinding binding;\n    private ProgressBar progbar;\n    //private PostingRecyclerView recyclerPostView;\n    private FloatingActionButton fabWrite;\n    //private TextView tvEmptyView;\n    //private TextView tvSorting;\n    // Fields\n    private String automaker;\n    private int currentPage;\n    private boolean isViewOrder;\n    private boolean isLoading; // to block recyclerview from scrolling while loading posts.\n    private int index;\n    private int position;\n    //private boolean isLastPage;\n    //private boolean isViewUpdated;\n    //private boolean isScrolling;\n\n    // Constructor\n    public BoardPagerFragment() {\n        // Required empty public constructor\n    }\n\n    public static BoardPagerFragment newInstance(int page, ArrayList<String> values){\n        BoardPagerFragment fragment = new BoardPagerFragment();\n        Bundle args = new Bundle();\n        args.putInt(\"currentPage\", page);\n        args.putStringArrayList(\"autoFilter\", values);\n        fragment.setArguments(args);\n        return fragment;\n    }\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setHasOptionsMenu(true);\n\n        if(getArguments() != null) {\n            currentPage = getArguments().getInt(\"currentPage\");\n            autoFilter = getArguments().getStringArrayList(\"autoFilter\");\n            if(autoFilter != null && autoFilter.size() > 0) automaker = autoFilter.get(0);\n        }\n\n        progbar = ((BoardActivity)requireActivity()).getLoadingProgressBar();\n        imgutil = new ApplyImageResourceUtil(getContext());\n        sdf = new SimpleDateFormat(\"MM.dd HH:mm\", Locale.getDefault());\n\n        // Instantiate objects.\n        //multiTypeItemList = new ArrayList<>();\n        postingList = new ArrayList<>();\n        firestore = FirebaseFirestore.getInstance();\n        // Instantiate the query and pagination util class and create the RecyclerView adapter to\n        // show the posting list.\n        postingAdapter = new BoardPostingAdapter(postingList, this);\n        //postingAdapter = new BoardPostingAdapter(multiTypeItemList, this);\n        queryPagingUtil = new QueryPostPaginationUtil(firestore, this);\n        colRef = firestore.collection(\"user_post\");\n        //source = (source == null) ? Source.SERVER : Source.CACHE;\n        if(currentPage == AUTOCLUB) queryPagingUtil.setAutoclubOrder(isViewOrder);\n        regListener = queryPagingUtil.setPostQuery(colRef, currentPage);\n        isLoading = true;\n\n        /*\n        regListener = colRef.addSnapshotListener(MetadataChanges.INCLUDE, (q, e) -> {\n            if(e != null) return;\n            source = (q != null && q.getMetadata().hasPendingWrites())? Source.CACHE : Source.SERVER;\n            log.i(\"snapshot: %s\", source);\n            if(source == Source.SERVER) {\n                if(currentPage == AUTOCLUB) queryPagingUtil.setAutoclubOrder(isViewOrder);\n                queryPagingUtil.setPostQuery(currentPage);\n                isLoading = true;\n            }\n        });\n\n         */\n\n\n\n        // Refactor required to resonse to realtime change.\n        /*\n        if(currentPage == AUTOCLUB) {\n            //clubRepo = new QueryClubPostingUtil(firestore);\n            //clubRepo.setOnPaginationListener(this);\n            postingAdapter = new BoardPostingAdapter(clubshotList, this);\n        } else {\n            //postRepo = new PostingBoardRepository();\n            //postingModel = new ViewModelProvider(this, new PostingBoardModelFactory(postRepo)).get(PostingBoardViewModel.class);\n            postingAdapter = new BoardPostingAdapter(postshotList, this);\n        }\n         */\n\n        // Implement OnFilterCheckBoxListener to receive values of the chkbox each time any chekcbox\n        // values changes.\n        //BoardPagerAdapter pagerAdapter = ((BoardActivity) requireActivity()).getPagerAdapter();\n\n    }\n\n    @Override\n    public View onCreateView(\n            @NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n        binding = FragmentBoardPagerBinding.inflate(inflater);\n        // Wrapping class to trhow IndexOutOfBound exception which is occasionally casued by RecyclerView.\n        //WrapContentLinearLayoutManager layoutManager = new WrapContentLinearLayoutManager(requireActivity());\n        LinearLayoutManager layout = new LinearLayoutManager(getContext(), LinearLayoutManager.VERTICAL, false);\n        RecyclerDividerUtil divider = new RecyclerDividerUtil(Constants.DIVIDER_HEIGHT_POSTINGBOARD,\n                0, ContextCompat.getColor(requireContext(), R.color.recyclerDivider));\n        binding.recyclerBoardPostings.setHasFixedSize(false); //due to banner plugin\n        binding.recyclerBoardPostings.setLayoutManager(layout);\n        binding.recyclerBoardPostings.addItemDecoration(divider);\n        binding.recyclerBoardPostings.setItemAnimator(new DefaultItemAnimator());\n        //SimpleItemAnimator itemAnimator = (SimpleItemAnimator)binding.recyclerBoardPostings.getItemAnimator();\n        //itemAnimator.setSupportsChangeAnimations(false);\n        binding.recyclerBoardPostings.setAdapter(postingAdapter);\n        binding.recyclerBoardPostings.addOnScrollListener(scrollListener);\n\n        // Show/hide Floating Action Button as the recyclerview scrolls.\n        fabWrite = ((BoardActivity)Objects.requireNonNull(requireActivity())).getFAB();\n\n        /* Based on MVVM\n        if(currentPage == BoardActivity.AUTOCLUB) {\n            // Initialize the club board if any filter is set.\n            if(!TextUtils.isEmpty(automaker)) {\n                isLastPage = false;\n                //postshotList.clear();\n                clubshotList.clear();\n                clubRepo.setPostingQuery(isViewOrder);\n            }\n        } else queryPostSnapshot(currentPage);\n        */\n        return binding.getRoot();\n    }\n\n\n    @Override\n    public void onViewCreated(@NonNull View view, Bundle savedInstanceState) {\n        super.onViewCreated(view, savedInstanceState);\n        FragmentSharedModel fragmentModel = new ViewModelProvider(requireActivity()).get(FragmentSharedModel.class);\n\n        /*\n        // BoardWriteFragment\n        fragmentModel.getNewPosting().observe(getViewLifecycleOwner(), postRef -> {\n            postRef.get().addOnSuccessListener(postshot -> {\n                log.i(\"add in onViewCreated\");\n                //postingList.add(0, postshot);\n                //postingAdapter.notifyItemInserted(0);\n                //postingAdapter.notifyItemRangeChanged(0, postingList.size(), \"ADD\");\n                //source = Source.CACHE;\n                queryPagingUtil.setPostQuery(colRef, currentPage);\n                binding.recyclerBoardPostings.smoothScrollToPosition(View.FOCUS_UP);\n            }).addOnFailureListener(Throwable::printStackTrace);\n        });\n\n        // BoardEditFragment\n        fragmentModel.getEditedPosting().observe(getViewLifecycleOwner(), postRef -> {\n            postRef.get().addOnSuccessListener(postshot -> {\n                log.i(\"edit in onViewCreated: %s\", this.position);\n                //postingList.set(position, postshot);\n                //postingAdapter.notifyItemChanged(position);\n                //source = Source.CACHE;\n                //queryPagingUtil.setPostQuery(source, currentPage);\n            });\n        });\n\n        // BoardReadFragment\n        fragmentModel.getRemovedPosting().observe(getViewLifecycleOwner(), pos -> {\n            log.i(\"remove in onViewCreated:%s\", pos);\n            //postingList.remove(postingList.get(pos)); // Why?\n            //postingAdapter.notifyItemRemoved(position);\n            //postingAdapter.notifyItemRangeChanged(position, postingList.size(), \"DELETE\");\n            //source = Source.CACHE;\n            queryPagingUtil.setPostQuery(colRef, currentPage);\n        });\n        */\n\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n    }\n\n    @Override\n    public void onPause() {\n        super.onPause();\n    }\n\n    @Override\n    public void onStop() {\n        super.onStop();\n        if(regListener != null) regListener.remove();\n    }\n\n    // Create the toolbar menu of the auto club page in the fragment, not in the activity, which\n    // should be customized to have an imageview and textview underneath instead of setting icon\n    // by setting actionLayout(app:actionLayout in xml).\n    @Override\n    public void onCreateOptionsMenu(@NonNull Menu menu, @NonNull MenuInflater inflater) {\n        // Do something different from in the parent activity\n        //this.menu = menu;\n        //menu.getItem(0).setVisible(false);\n        //menu.getItem(1).setVisible(false);\n        if(currentPage == AUTOCLUB) {\n            View actionView = menu.getItem(0).getActionView();\n            ImageView imgEmblem = actionView.findViewById(R.id.img_action_emblem);\n            ProgressBar pbEmblem = actionView.findViewById(R.id.pb_emblem);\n\n            if(TextUtils.isEmpty(automaker)) {\n                menu.getItem(0).setVisible(false);\n                //actionView.setVisibility(View.INVISIBLE);\n            } else {\n                menu.getItem(0).setVisible(true);\n                actionView.setVisibility(View.VISIBLE);\n                setAutoMakerEmblem(pbEmblem, imgEmblem);\n                actionView.setOnClickListener(view -> onOptionsItemSelected(menu.getItem(0)));\n            }\n\n        } else super.onCreateOptionsMenu(menu, inflater);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        if(item.getItemId() == R.id.action_automaker_emblem) {\n            rotateAutoEmblem(item).start();\n            return true;\n        }\n        return false;\n    }\n\n    /*\n    @Override\n    public void notifyDialogDismissed(int position) {\n        log.i(\"Read Dialog dismissed:%s\", position);\n        // This problem is caused by RecyclerView Data modified in different thread.\n        // The best way is checking all data access. And a workaround is wrapping LinearLayoutManager.\n        //postingAdapter.notifyItemRemoved(position);\n        log.i(\"Item size: %s\", multiTypeItemList.size());\n        pagerAdapter.notifyItemChanged(currentPage);\n        //((BoardActivity)requireActivity()).addViewPager();\n    }\n\n     */\n\n    /*\n     * Implement QueryPaginationUtil.OnQueryPaginationCallback overriding the following 4 methods that\n     * performs to query posts with orderBy() and limit() conditioned up to the pagination number\n     * which is defined in BoardActivity.PAGINATION.\n     *\n     * getFirestQueryResult(): setPostQuery() has completed with queried posts up to the pagination number.\n     * getNextQueryResult(): setNextQuery() has completed with queried posts up to the pagination number.\n     * getLastQueryResult(); setNextQuery() has completed with queried posts under the pagination number.\n     * getQueryErrorResult(); callback invoked if any error has occurred while querying.\n     */\n\n    @Override\n    public void getFirstQueryResult(QuerySnapshot querySnapshot) {\n        //log.i(\"first query: %s, %s\", postingList.size(), querySnapshot.size());\n        //index = 0;\n        //multiTypeItemList.clear();\n        postingList.clear();\n        log.i(\"initial postingList: %s\", postingList.size());\n        if(querySnapshot.size() == 0) {\n            progbar.setVisibility(View.GONE);\n            binding.recyclerBoardPostings.setVisibility(View.GONE);\n            binding.tvEmptyView.setVisibility(View.VISIBLE);\n            return;\n        } else {\n            binding.recyclerBoardPostings.setVisibility(View.VISIBLE);\n            binding.tvEmptyView.setVisibility(View.GONE);\n        }\n\n        // Add DocumentSnapshot to List<DocumentSnapshot> which is paassed to RecyclerView.Adapter.\n        // The autoclub page should separately handle query and pagination to sorts out the document\n        // snapshot with given filters.\n        for(DocumentSnapshot document : querySnapshot) {\n            if (currentPage == AUTOCLUB) sortClubPost(document);\n            else {\n                postingList.add(document);\n                //multiTypeItemList.add(new MultiTypeItem(0, index, document));\n            }\n            //index++;\n        }\n\n        // Test Code: for pre-occupying the banner slot.\n        //addDummySlotForAds();\n        //multiTypeItemList.add(new MultiTypeItem(1));\n        postingAdapter.notifyItemRangeChanged(0, querySnapshot.size());\n        progbar.setVisibility(View.GONE);\n        isLoading = false;\n\n        // If the sorted posts are less than the pagination number, keep querying until it's up to\n        // the number. Manually update the adapter each time posts amount to the pagination number.\n        if(currentPage == AUTOCLUB) {\n            //if(multiTypeItemList.size() < PAGINATION) {\n            if(postingList.size() < PAGINATION) {\n                isLoading = true;\n                queryPagingUtil.setNextPostQuery();\n            }\n        }\n    }\n\n    @Override\n    public void getNextQueryResult(QuerySnapshot nextShots) {\n        //final int start = multiTypeItemList.size();\n        final int start = postingList.size();\n        for(DocumentSnapshot document : nextShots) {\n            if (currentPage == AUTOCLUB) sortClubPost(document);\n            else {\n                postingList.add(document);\n                //multiTypeItemList.add(new MultiTypeItem(0, index, document));\n            }\n            //index++;\n        }\n\n        // ADD THE AD BANNER: refactor required for the convenience's sake.\n        //multiTypeItemList.add(new MultiTypeItem(1));\n        postingAdapter.notifyItemRangeChanged(start, nextShots.size());\n        //binding.progbarBoardPaging.setVisibility(View.INVISIBLE);\n\n        // Keep querying if sorted posts are less than the pagination number. When it reaches the\n        // number, update the apdater.\n        if(currentPage == AUTOCLUB) {\n            //if(multiTypeItemList.size() < PAGINATION) {\n            if(postingList.size() < PAGINATION) {\n                isLoading = true;\n                queryPagingUtil.setNextPostQuery();\n            }//else postingAdapter.notifyDataSetChanged();\n        }\n        isLoading = false;\n    }\n\n    @Override\n    public void getLastQueryResult(QuerySnapshot lastShots) {\n        final int start = postingList.size();\n        //final int start = multiTypeItemList.size();\n        //int index = snapshotList.size();\n        for(DocumentSnapshot document : lastShots) {\n            if(currentPage == AUTOCLUB) sortClubPost(document);\n            else {\n                postingList.add(document);\n                //multiTypeItemList.add(new MultiTypeItem(0, index, document));\n            }\n            index++;\n        }\n        postingAdapter.notifyItemRangeChanged(start, lastShots.size());\n        //binding.progbarBoardPaging.setVisibility(View.GONE);\n        //isLoading = true; // Block the scroll listener from keeping querying.\n        binding.recyclerBoardPostings.removeOnScrollListener(scrollListener);\n\n        // On clicking the filter item on the autoclub page, if nothing has been posted, display\n        // the empty view.\n        if(currentPage == AUTOCLUB && postingList.size() == 0) {\n        //if(currentPage == AUTOCLUB && multiTypeItemList.size() == 0) {\n            //recyclerPostView.setEmptyView(binding.tvEmptyView);\n            //binding.recyclerBoardPostings.setEmptyView(binding.tvEmptyView);\n            binding.recyclerBoardPostings.setVisibility(View.GONE);\n            binding.tvEmptyView.setVisibility(View.VISIBLE);\n        } else {\n            binding.recyclerBoardPostings.setVisibility(View.VISIBLE);\n            binding.tvEmptyView.setVisibility(View.GONE);\n        }\n    }\n\n    @Override\n    public void getRemovedQueryResult(DocumentSnapshot doc) {\n        log.i(\"position: %s\", this.position);\n        postingList.remove(doc);\n        postingAdapter.notifyItemRemoved(position);\n        postingAdapter.notifyItemRangeChanged(position, postingList.size(), \"REMOVED\");\n    }\n\n    @Override\n    public void getModifiedQueryResult(DocumentSnapshot doc) {\n        log.i(\"added or edited\");\n    }\n\n    @Override\n    public void getQueryErrorResult(Exception e) {\n        progbar.setVisibility(View.GONE);\n        e.printStackTrace();\n        Toast.makeText(getActivity(), e.getMessage(), Toast.LENGTH_SHORT).show();\n        //isLoading = true;\n        binding.recyclerBoardPostings.removeOnScrollListener(scrollListener);\n    }\n\n    //Implement BoardPostingAdapter.OnRecyclerItemClickListener when an item is clicked.\n    //@SuppressWarnings({\"unchecked\", \"ConstantConditions\"})\n    @Override\n    public void onPostClicked(DocumentSnapshot snapshot, int position) {\n        // Initiate the task to query the board collection and the user collection.\n        // Show the dialog with the full screen. The container is android.R.id.content.\n        log.i(\"reset position: %s\", position);\n        this.position = position;\n        BoardReadFragment readPostFragment = new BoardReadFragment();\n        log.i(\"BoardReadFragment: %s\", readPostFragment.hashCode());\n\n        CustomPostingObject toObject = snapshot.toObject(CustomPostingObject.class);\n        assert toObject != null;\n        Bundle bundle = new Bundle();\n        bundle.putInt(\"tabPage\", currentPage);\n        bundle.putInt(\"position\", position);\n        bundle.putString(\"documentId\", snapshot.getId());\n        bundle.putParcelable(\"postingObj\", toObject);\n\n        readPostFragment.setArguments(bundle);\n        requireActivity().getSupportFragmentManager().beginTransaction()\n                .add(android.R.id.content, readPostFragment)\n                .addToBackStack(null)\n                .commit();\n\n        // Update the field of \"cnt_view\" increasing the number.\n        //DocumentReference docref = snapshot.getReference();\n        addViewCount(snapshot.getReference(), position);\n    }\n\n    //Invoked from the parent activity to pass checkbox changes made by OnCheckedChange() to make\n    //a new query w/ the Autoclub page.\n    public void setCheckBoxValueChange(ArrayList<String> autofilter){\n        this.autoFilter = autofilter;\n        for(String filter : autofilter) log.i(\"autofilter changed: %s\", filter);\n    }\n\n    // This method sorts out the autoclub posts based on the autofilter by removing a document out of\n    // the list if it has no autofilter field or its nested filter which can be accessed w/ the dot\n    // notation\n    private void sortClubPost(DocumentSnapshot snapshot) {\n        postingList.add(snapshot);\n        //multiTypeItemList.add(new MultiTypeItem(0, index, snapshot));\n        if(snapshot.get(\"auto_filter\") == null) postingList.remove(snapshot);\n        else {\n            for(String filter : autoFilter) {\n                if ((snapshot.get(\"auto_filter.\" + filter) == null)) {\n                    postingList.remove(snapshot);\n                    break;\n                }\n            }\n        }\n    }\n\n    // RecyclerView.OnScrollListener is an abstract class to receive messages when a scrolling event\n    // has occurred on that RecyclerView, which has 2 abstract methods of onScrollStateChanged() and\n    // onScrolled(); the former is to be invoked when RecyclerView's scroll state changes and the\n    // latter invoked when the RecyclerView has been scrolled.\n    //private RecyclerView.OnScrollListener setRecyclerViewScrollListener() {\n    private final RecyclerView.OnScrollListener scrollListener = new RecyclerView.OnScrollListener(){\n        /* Callback to be invoked when the RecyclerView has been scrolled, which will be called\n         * right after the scroll has completed. This callback will also be called if visible\n         * item range changes after a layout calculation, in which dx and dy will be 0.\n         * @param recyclerView being scrolled\n         * @param dx The amount of horizontal scroll\n         * @param dy The amount of vertical scroll\n         */\n        @Override\n        public void onScrolled(@NonNull RecyclerView recyclerView, int dx, int dy) {\n            super.onScrolled(recyclerView, dx, dy);\n            fabWrite.setAlpha(0.8f);\n            //WrapContentLinearLayoutManager layout = (WrapContentLinearLayoutManager)recyclerView.getLayoutManager();\n            LinearLayoutManager layout = (LinearLayoutManager)recyclerView.getLayoutManager();\n            if (layout != null) {\n                int firstVisibleProductPosition = layout.findFirstVisibleItemPosition();\n                int visiblePostCount = layout.getChildCount();\n                int totalPostCount = layout.getItemCount();\n                //log.i(\"totalPostCount: %s, %s, %s\", firstVisibleProductPosition, visiblePostCount, totalPostCount);\n\n                if (!isLoading && (firstVisibleProductPosition + visiblePostCount == totalPostCount)) {\n                    //isScrolling = false;\n                    isLoading = true;\n                    //if(currentPage != AUTOCLUB) pbPaging.setVisibility(View.VISIBLE);\n                    // If the totalPostCount is less than PAGINATION, setNextQuery will\n                    // return null value, which results in an error as in Notification board. Accrodingly,\n                    // a condition has to be added to prevent setNextQuery().\n                    if(currentPage != AUTOCLUB && totalPostCount >= PAGINATION) {\n                        //binding.progbarBoardPaging.setVisibility(View.VISIBLE);\n                        queryPagingUtil.setNextPostQuery();\n                    }\n\n                    //if(currentPage != AUTOCLUB) queryPostSnapshot(currentPage);\n                    //else if(!isLastPage) clubRepo.setNextQuery();\n                }\n            }\n        }\n\n    };\n\n\n\n    /*\n     * Check if a user is the post's owner or has read the post before in order to increate the view\n     * count. In order to do so, get the user id from the internal storage and from the post as well.\n     * Get the user id and query the \"viewers\" sub-collection to check if the user id exists in the\n     * documents, which means whether the user has read the post before. If so, do not increase\n     * the view count. Otherwise, add the user id to the \"viewers\" collection and increase the\n     * view count;\n     */\n    private void addViewCount(DocumentReference docref, int pos) {\n        try(FileInputStream fis = Objects.requireNonNull(requireActivity()).openFileInput(\"userId\");\n            BufferedReader br = new BufferedReader(new InputStreamReader(fis))) {\n            final String viewerId = br.readLine();\n\n            //CollectionReference subCollection = docref.collection(\"viewers\");\n            DocumentReference viewerRef = docref.collection(\"viewers\").document(viewerId);\n            firestore.runTransaction(transaction -> {\n                DocumentSnapshot viewershot = transaction.get(viewerRef);\n                if(!viewershot.exists()) {\n                    docref.update(\"cnt_view\", FieldValue.increment(1));\n                    Map<String, Object> data = new HashMap<>();\n                    data.put(\"timestamp\", FieldValue.serverTimestamp());\n                    data.put(\"viewer_ip\", \"192.0.0.255\"); // code for getting the viewer id required.\n                    docref.collection(\"viewers\").document(viewerId).set(data, SetOptions.merge())\n                            .addOnSuccessListener(aVoid -> {\n                                docref.get().addOnSuccessListener(doc ->\n                                    postingAdapter.notifyItemChanged(pos, doc.getLong(\"cnt_view\"))\n                                );\n                            }).addOnFailureListener(Throwable::printStackTrace);\n                }\n                return null;\n            });\n            /*\n            subCollection.document(viewerId).get().addOnSuccessListener(snapshot -> {\n                // In case the user has not read the post before and adoes not exists in the \"viewers\"\n                // collection\n                if(!snapshot.exists()) {\n                  docref.update(\"cnt_view\", FieldValue.increment(1));\n                  // Set timestamp and the user ip with the user id used as the document id.\n                  Map<String, Object> viewerData = new HashMap<>();\n\n                  viewerData.put(\"timestamp\", FieldValue.serverTimestamp());\n                  viewerData.put(\"viewer_ip\", \"\");\n\n                  subCollection.document(viewerId).set(viewerData).addOnSuccessListener(aVoid -> {\n                      // Listener to events for local changes, which is notified with the new data\n                      // before the data is sent to the backend.\n                      docref.get().addOnSuccessListener(data -> {\n                          if(data.exists())\n                              // Partial binding to BoardPostingAdapter to update the view count in\n                              // the post document.\n                              postingAdapter.notifyItemChanged(pos, data.getLong(\"cnt_view\"));\n                      }).addOnFailureListener(Exception::printStackTrace);\n                  });\n                }\n            });\n            */\n\n        } catch(IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    // Attemp to retrieve the emblem uri from Firestore only when an auto maker is provided. For this\n    // reason, the method should be placed at the end of createAutoFilterCheckBox() which receives\n    // auto data as json type.\n    private void setAutoMakerEmblem(ProgressBar pb, ImageView imgview) {\n        // Make the progressbar visible until getting the emblem from Firetore\n        pb.setVisibility(View.VISIBLE);\n        firestore.collection(\"autodata\").document(automaker).get().addOnSuccessListener(doc -> {\n            String emblem = doc.getString(\"auto_emblem\");\n            if(TextUtils.isEmpty(emblem)) return;\n            else {\n                Uri uri = Uri.parse(emblem);\n                final int x = imgview.getMeasuredWidth();\n                final int y = imgview.getMeasuredHeight();\n                imgutil.applyGlideToEmblem(uri, x, y, imgview);\n            }\n\n            pb.setVisibility(View.GONE);\n\n        });\n\n        /*\n        //firestore.collection(\"autodata\").whereEqualTo(\"auto_maker\", automaker).get()\n        firestore.collection(\"autodata\").whereEqualTo(FieldPath.documentId(), automaker).get()\n                .addOnSuccessListener(queires -> {\n                    for(QueryDocumentSnapshot autoshot : queires) {\n                        String emblem = autoshot.getString(\"auto_emblem\");\n                        // Empty Check. Refactor should be taken to show an empty icon, instead.\n                        if(TextUtils.isEmpty(emblem)) return;\n                        else {\n                            Uri uri = Uri.parse(emblem);\n                            final int x = imgview.getMeasuredWidth();\n                            final int y = imgview.getMeasuredHeight();\n                            imgutil.applyGlideToEmblem(uri, x, y, imgview);\n                        }\n\n                        pb.setVisibility(View.GONE);\n                        break;\n                    }\n                }).addOnFailureListener(e -> {\n                    pb.setVisibility(View.GONE);\n                    e.printStackTrace();\n                });\n\n         */\n    }\n    private ObjectAnimator rotateAutoEmblem(MenuItem item) {\n        ObjectAnimator rotation = ObjectAnimator.ofFloat(item.getActionView(), \"rotationY\", 0.0f, 360f);\n        rotation.setDuration(500);\n        rotation.setInterpolator(new AccelerateDecelerateInterpolator());\n        // Use AnimatorListenerAdapter to take callback methods seletively.\n        rotation.addListener(new AnimatorListenerAdapter(){\n            @Override\n            public void onAnimationEnd(Animator animation, boolean isReverse) {\n                rotation.cancel();\n                String sorting = (isViewOrder)? getString(R.string.board_autoclub_sort_time) :\n                        getString(R.string.board_autoclub_sort_view);\n                TextView tvSorting = item.getActionView().findViewById(R.id.tv_sorting_order);\n                tvSorting.setText(sorting);\n                isViewOrder = !isViewOrder;\n            }\n        });\n\n        return rotation;\n    }\n\n    public static class MultiTypeItem {\n        DocumentSnapshot snapshot;\n        int index;\n        int viewType;\n\n        public MultiTypeItem(int viewType, int index, DocumentSnapshot snapshot) {\n            this.snapshot = snapshot;\n            this.viewType = viewType;\n            this.index = index;\n        }\n\n        public MultiTypeItem(int viewType){\n            this.viewType = viewType;\n        }\n        public DocumentSnapshot getItemSnapshot() {\n            return snapshot;\n        }\n        public int getViewType() {\n            return viewType;\n        }\n        public int getItemIndex() {\n            return index;\n        }\n    }\n\n    // Wrapper class to throw java.lang.IndexOutOfBoundsException: Inconsistency detected.\n    // Invalid view holder adapter positionPostViewHolder\n    private static class WrapContentLinearLayoutManager extends LinearLayoutManager {\n        // Constructor\n        public WrapContentLinearLayoutManager(Context context) {\n            super(context, LinearLayoutManager.VERTICAL, false);\n        }\n\n        @Override\n        public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {\n            try {\n                super.onLayoutChildren(recycler, state);\n            } catch(IndexOutOfBoundsException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    /*\n    // Callback implemented by QueryClubPostingUtil.setPostingQuery() when initiating query for\n    // the autoclub post. Receiving a result querysnapshot, categorize each snapshot by type, then\n    // update the postshotList. To get the club list, filter the postshot list with the autofilter\n    // using sortAutoClubPost(), adding a filtered snapshot to the club list. If the club list is\n    // less than the pagination number, keep querying posts to add more club posts, calling\n    // QueryClubPostingUtil.setNextQuery().\n    @Override\n    public void setClubQuerySnapshot(QuerySnapshot snapshots) {\n        clubshotList.clear();\n        if(snapshots.size() == 0) {\n            recyclerPostView.setEmptyView(binding.tvEmptyView);\n            return;\n        }\n\n        for(DocumentChange documentChange : snapshots.getDocumentChanges()) {\n            switch(documentChange.getType()) {\n                case ADDED:\n                    DocumentSnapshot addSnapshot = documentChange.getDocument();\n                    postshotList.add(addSnapshot);\n                    sortAutoClubPost(addSnapshot);\n                    break;\n\n                case MODIFIED:\n                    DocumentSnapshot modifySnapshot = documentChange.getDocument();\n                    for(int i = 0; i < postshotList.size(); i++) {\n                        DocumentSnapshot snapshot = postshotList.get(i);\n                        if(snapshot.getId().equals(modifySnapshot.getId())) {\n                            postshotList.remove(snapshot);\n                            postshotList.add(i, modifySnapshot);\n                            break;\n                        }\n                    }\n\n                    sortAutoClubPost(modifySnapshot);\n                    break;\n\n                case REMOVED:\n                    DocumentSnapshot removeSnapshot = documentChange.getDocument();\n                    for(int i = 0; i < postshotList.size(); i++) {\n                        DocumentSnapshot snapshot = postshotList.get(i);\n                        if(snapshot.getId().equals(removeSnapshot.getId())) {\n                            postshotList.remove(snapshot);\n                            break;\n                        }\n                    }\n\n                    sortAutoClubPost(removeSnapshot);\n                    break;\n            }\n        }\n\n        if(snapshots.size() < Constants.PAGINATION) {\n            isLastPage = true;\n            postingAdapter.notifyDataSetChanged();\n        } else {\n            isLastPage = false;\n            if(clubshotList.size() < Constants.PAGINATION) clubRepo.setNextQuery();\n            else postingAdapter.notifyDataSetChanged();\n        }\n\n        pbLoading.setVisibility(View.GONE);\n    }\n\n    // This method sorts out the autoclub posts based on the autofilter by removing a document out of\n    // the list if it has no autofilter field or its nested filter which can be accessed w/ the dot\n    // notation\n    private void sortAutoClubPost(DocumentSnapshot snapshot) {\n        clubshotList.add(snapshot);\n        if(snapshot.get(\"auto_filter\") == null) clubshotList.remove(snapshot);\n        else {\n            for(String filter : autoFilter) {\n                if ((snapshot.get(\"auto_filter.\" + filter) == null)) {\n                    clubshotList.remove(snapshot);\n                    break;\n                }\n            }\n        }\n    }\n\n    // Query the general board except for the club board.\n    private void queryPostSnapshot(int page) {\n        postRepo.setPostingQuery(page);\n\n        // Notified of documentsnapshot from the livedata\n        PostingBoardLiveData postLiveData = postingModel.getPostingBoardLiveData();\n        if(postLiveData != null) {\n            postLiveData.observe(getViewLifecycleOwner(), operation -> {\n                log.i(\"operation thread: %s\", Thread.currentThread());\n\n                int type = operation.getType();\n                DocumentSnapshot postshot = operation.getDocumentSnapshot();\n                // Add a post only if the post_general field is set to true at the general board.\n                switch(type) {\n                    case 0: // ADDED\n                        log.i(\"Added: %s, %s\", currentPage, postshot.getString(\"post_title\"));\n                        postshotList.add(postshot);\n                        break;\n\n                    case 1: // MODIFIED\n                        log.i(\"Modified: %s, %s\", currentPage, postshot.getString(\"post_title\"));\n                        for(int i = 0; i < postshotList.size(); i++) {\n                            DocumentSnapshot snapshot = postshotList.get(i);\n                            if(snapshot.getId().equals(postshot.getId())) {\n                                postshotList.remove(snapshot);\n                                postshotList.add(i, postshot);\n                                break;\n                            }\n                        }\n\n                        break;\n\n                    case 2: // REMOVED\n                        log.i(\"Removed: %s, %s\", currentPage, postshot.getString(\"post_title\"));\n                        for(int i = 0; i < postshotList.size(); i++) {\n                            DocumentSnapshot snapshot = postshotList.get(i);\n                            if(snapshot.getId().equals(postshot.getId())) {\n                                log.i(\"snapshot removed: %s\", snapshot.getString(\"post_title\"));\n                                postshotList.remove(snapshot);\n                                break;\n                            }\n\n                        }\n\n                        break;\n                }\n\n                postingAdapter.notifyDataSetChanged();\n            });\n\n            pbLoading.setVisibility(View.GONE);\n        }\n    }\n    */\n}\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/silverback/carman/fragments/BoardPagerFragment.java b/app/src/main/java/com/silverback/carman/fragments/BoardPagerFragment.java
--- a/app/src/main/java/com/silverback/carman/fragments/BoardPagerFragment.java	
+++ b/app/src/main/java/com/silverback/carman/fragments/BoardPagerFragment.java	
@@ -529,7 +529,7 @@
     //a new query w/ the Autoclub page.
     public void setCheckBoxValueChange(ArrayList<String> autofilter){
         this.autoFilter = autofilter;
-        for(String filter : autofilter) log.i("autofilter changed: %s", filter);
+        //for(String filter : autofilter) log.i("autofilter changed: %s", filter);
     }
 
     // This method sorts out the autoclub posts based on the autofilter by removing a document out of

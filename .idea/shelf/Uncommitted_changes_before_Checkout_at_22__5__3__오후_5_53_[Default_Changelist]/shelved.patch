Index: app/src/main/java/com/silverback/carman/fragments/BoardPagerFragment.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.silverback.carman.fragments;\n\n\nimport static com.silverback.carman.BoardActivity.AUTOCLUB;\nimport static com.silverback.carman.BoardActivity.PAGINATION;\n\nimport android.animation.Animator;\nimport android.animation.AnimatorListenerAdapter;\nimport android.animation.ObjectAnimator;\nimport android.content.Context;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.text.TextUtils;\nimport android.view.LayoutInflater;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.animation.AccelerateDecelerateInterpolator;\nimport android.widget.ImageView;\nimport android.widget.ProgressBar;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport androidx.annotation.NonNull;\nimport androidx.core.content.ContextCompat;\nimport androidx.fragment.app.Fragment;\nimport androidx.lifecycle.ViewModelProvider;\nimport androidx.recyclerview.widget.DefaultItemAnimator;\nimport androidx.recyclerview.widget.LinearLayoutManager;\nimport androidx.recyclerview.widget.RecyclerView;\n\nimport com.google.android.material.floatingactionbutton.FloatingActionButton;\nimport com.google.firebase.firestore.CollectionReference;\nimport com.google.firebase.firestore.DocumentReference;\nimport com.google.firebase.firestore.DocumentSnapshot;\nimport com.google.firebase.firestore.FieldValue;\nimport com.google.firebase.firestore.FirebaseFirestore;\nimport com.google.firebase.firestore.ListenerRegistration;\nimport com.google.firebase.firestore.MetadataChanges;\nimport com.google.firebase.firestore.QuerySnapshot;\nimport com.google.firebase.firestore.SetOptions;\nimport com.google.firebase.firestore.Source;\nimport com.silverback.carman.BoardActivity;\nimport com.silverback.carman.R;\nimport com.silverback.carman.adapters.BoardPostingAdapter;\nimport com.silverback.carman.databinding.FragmentBoardPagerBinding;\nimport com.silverback.carman.logs.LoggingHelper;\nimport com.silverback.carman.logs.LoggingHelperFactory;\nimport com.silverback.carman.utils.ApplyImageResourceUtil;\nimport com.silverback.carman.utils.Constants;\nimport com.silverback.carman.utils.CustomPostingObject;\nimport com.silverback.carman.utils.QueryPostPaginationUtil;\nimport com.silverback.carman.utils.RecyclerDividerUtil;\nimport com.silverback.carman.viewmodels.FragmentSharedModel;\n\nimport java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Objects;\n\n/*\n * The viewpager statically creates this fragment using BoardPagerAdapter, which has the custom\n * recyclerview to show the posting board by category.\n *\n * QueryPostPaginationUtil is a util class that performs query and pagination based on orderby() and\n * limit(). This class is made of the initial, next, and last query for pagination, listening to\n * scrolling of the recyclerview. MVVM-based architecture is provided in the board package just for\n * referernce.\n *\n * Instead of using SnapshotListener for realtime update, which seems difficult to handle cache data\n * in the viewpager fragments, the util simply reads posts using get() and updates are made by requerying\n * posts notified by the viewmodel(FragmentSharedModel). Comments in BoardReadFragment, however,\n * applies SnapshotListener.\n *\n * Refactoring based on MVVM to improve the query performance should be made. At the moment, related\n * codes are commented.\n */\npublic class BoardPagerFragment extends Fragment implements\n        QueryPostPaginationUtil.OnQueryPaginationCallback,\n        //BoardReadFragment.OnDialogDismissListener,\n        //QueryClubPostingUtil.OnPaginationListener,\n        BoardPostingAdapter.OnRecyclerItemClickListener {\n\n    // Logging\n    private static final LoggingHelper log = LoggingHelperFactory.create(BoardPagerFragment.class);\n\n    // Objects\n    //private List<MultiTypeItem> multiTypeItemList;\n    private List<DocumentSnapshot> postingList;\n\n    private FirebaseFirestore firestore;\n    private ListenerRegistration regListener;\n    private CollectionReference colRef;\n    private Source source;\n    //private PostingBoardViewModel postingModel;\n    //private PostingBoardRepository postRepo;\n    //private QueryClubPostingUtil clubRepo;\n    //private ListenerRegistration listenerRegistration;\n    private QueryPostPaginationUtil queryPagingUtil;\n    private BoardPostingAdapter postingAdapter;\n\n    private ArrayList<String> autoFilter;\n    private SimpleDateFormat sdf;\n    private ApplyImageResourceUtil imgutil;\n    // UIs\n    private FragmentBoardPagerBinding binding;\n    private ProgressBar progbar;\n    //private PostingRecyclerView recyclerPostView;\n    private FloatingActionButton fabWrite;\n    //private TextView tvEmptyView;\n    //private TextView tvSorting;\n    // Fields\n    private String automaker;\n    private int currentPage;\n    private boolean isViewOrder;\n    private boolean isLoading; // to block recyclerview from scrolling while loading posts.\n    private int index;\n    private int position;\n    //private boolean isLastPage;\n    //private boolean isViewUpdated;\n    //private boolean isScrolling;\n\n    // Constructor\n    public BoardPagerFragment() {\n        // Required empty public constructor\n    }\n\n    public static BoardPagerFragment newInstance(int page, ArrayList<String> values){\n        BoardPagerFragment fragment = new BoardPagerFragment();\n        Bundle args = new Bundle();\n        args.putInt(\"currentPage\", page);\n        args.putStringArrayList(\"autoFilter\", values);\n        fragment.setArguments(args);\n        return fragment;\n    }\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setHasOptionsMenu(true);\n\n        if(getArguments() != null) {\n            currentPage = getArguments().getInt(\"currentPage\");\n            autoFilter = getArguments().getStringArrayList(\"autoFilter\");\n            if(autoFilter != null && autoFilter.size() > 0) automaker = autoFilter.get(0);\n        }\n\n        progbar = ((BoardActivity)requireActivity()).getLoadingProgressBar();\n        imgutil = new ApplyImageResourceUtil(getContext());\n        sdf = new SimpleDateFormat(\"MM.dd HH:mm\", Locale.getDefault());\n\n        // Instantiate objects.\n        //multiTypeItemList = new ArrayList<>();\n        postingList = new ArrayList<>();\n        firestore = FirebaseFirestore.getInstance();\n        // Instantiate the query and pagination util class and create the RecyclerView adapter to\n        // show the posting list.\n        postingAdapter = new BoardPostingAdapter(postingList, this);\n        //postingAdapter = new BoardPostingAdapter(multiTypeItemList, this);\n        queryPagingUtil = new QueryPostPaginationUtil(firestore, this);\n        colRef = firestore.collection(\"user_post\");\n        //source = (source == null) ? Source.SERVER : Source.CACHE;\n        if(currentPage == AUTOCLUB) queryPagingUtil.setAutoclubOrder(isViewOrder);\n        regListener = queryPagingUtil.setPostQuery(colRef, currentPage);\n        isLoading = true;\n\n        /*\n        regListener = colRef.addSnapshotListener(MetadataChanges.INCLUDE, (q, e) -> {\n            if(e != null) return;\n            source = (q != null && q.getMetadata().hasPendingWrites())? Source.CACHE : Source.SERVER;\n            log.i(\"snapshot: %s\", source);\n            if(source == Source.SERVER) {\n                if(currentPage == AUTOCLUB) queryPagingUtil.setAutoclubOrder(isViewOrder);\n                queryPagingUtil.setPostQuery(currentPage);\n                isLoading = true;\n            }\n        });\n\n         */\n\n\n\n        // Refactor required to resonse to realtime change.\n        /*\n        if(currentPage == AUTOCLUB) {\n            //clubRepo = new QueryClubPostingUtil(firestore);\n            //clubRepo.setOnPaginationListener(this);\n            postingAdapter = new BoardPostingAdapter(clubshotList, this);\n        } else {\n            //postRepo = new PostingBoardRepository();\n            //postingModel = new ViewModelProvider(this, new PostingBoardModelFactory(postRepo)).get(PostingBoardViewModel.class);\n            postingAdapter = new BoardPostingAdapter(postshotList, this);\n        }\n         */\n\n        // Implement OnFilterCheckBoxListener to receive values of the chkbox each time any chekcbox\n        // values changes.\n        //BoardPagerAdapter pagerAdapter = ((BoardActivity) requireActivity()).getPagerAdapter();\n\n    }\n\n    @Override\n    public View onCreateView(\n            @NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n        binding = FragmentBoardPagerBinding.inflate(inflater);\n        // Wrapping class to trhow IndexOutOfBound exception which is occasionally casued by RecyclerView.\n        //WrapContentLinearLayoutManager layoutManager = new WrapContentLinearLayoutManager(requireActivity());\n        LinearLayoutManager layout = new LinearLayoutManager(getContext(), LinearLayoutManager.VERTICAL, false);\n        RecyclerDividerUtil divider = new RecyclerDividerUtil(Constants.DIVIDER_HEIGHT_POSTINGBOARD,\n                0, ContextCompat.getColor(requireContext(), R.color.recyclerDivider));\n        binding.recyclerBoardPostings.setHasFixedSize(false); //due to banner plugin\n        binding.recyclerBoardPostings.setLayoutManager(layout);\n        binding.recyclerBoardPostings.addItemDecoration(divider);\n        binding.recyclerBoardPostings.setItemAnimator(new DefaultItemAnimator());\n        //SimpleItemAnimator itemAnimator = (SimpleItemAnimator)binding.recyclerBoardPostings.getItemAnimator();\n        //itemAnimator.setSupportsChangeAnimations(false);\n        binding.recyclerBoardPostings.setAdapter(postingAdapter);\n        binding.recyclerBoardPostings.addOnScrollListener(scrollListener);\n\n        // Show/hide Floating Action Button as the recyclerview scrolls.\n        fabWrite = ((BoardActivity)Objects.requireNonNull(requireActivity())).getFAB();\n\n        /* Based on MVVM\n        if(currentPage == BoardActivity.AUTOCLUB) {\n            // Initialize the club board if any filter is set.\n            if(!TextUtils.isEmpty(automaker)) {\n                isLastPage = false;\n                //postshotList.clear();\n                clubshotList.clear();\n                clubRepo.setPostingQuery(isViewOrder);\n            }\n        } else queryPostSnapshot(currentPage);\n        */\n        return binding.getRoot();\n    }\n\n\n    @Override\n    public void onViewCreated(@NonNull View view, Bundle savedInstanceState) {\n        super.onViewCreated(view, savedInstanceState);\n        FragmentSharedModel fragmentModel = new ViewModelProvider(requireActivity()).get(FragmentSharedModel.class);\n\n        /*\n        // BoardWriteFragment\n        fragmentModel.getNewPosting().observe(getViewLifecycleOwner(), postRef -> {\n            postRef.get().addOnSuccessListener(postshot -> {\n                log.i(\"add in onViewCreated\");\n                //postingList.add(0, postshot);\n                //postingAdapter.notifyItemInserted(0);\n                //postingAdapter.notifyItemRangeChanged(0, postingList.size(), \"ADD\");\n                //source = Source.CACHE;\n                queryPagingUtil.setPostQuery(colRef, currentPage);\n                binding.recyclerBoardPostings.smoothScrollToPosition(View.FOCUS_UP);\n            }).addOnFailureListener(Throwable::printStackTrace);\n        });\n\n        // BoardEditFragment\n        fragmentModel.getEditedPosting().observe(getViewLifecycleOwner(), postRef -> {\n            postRef.get().addOnSuccessListener(postshot -> {\n                log.i(\"edit in onViewCreated: %s\", this.position);\n                //postingList.set(position, postshot);\n                //postingAdapter.notifyItemChanged(position);\n                //source = Source.CACHE;\n                //queryPagingUtil.setPostQuery(source, currentPage);\n            });\n        });\n\n        // BoardReadFragment\n        fragmentModel.getRemovedPosting().observe(getViewLifecycleOwner(), pos -> {\n            log.i(\"remove in onViewCreated:%s\", pos);\n            //postingList.remove(postingList.get(pos)); // Why?\n            //postingAdapter.notifyItemRemoved(position);\n            //postingAdapter.notifyItemRangeChanged(position, postingList.size(), \"DELETE\");\n            //source = Source.CACHE;\n            queryPagingUtil.setPostQuery(colRef, currentPage);\n        });\n        */\n\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n    }\n\n    @Override\n    public void onPause() {\n        super.onPause();\n    }\n\n    @Override\n    public void onStop() {\n        super.onStop();\n        if(regListener != null) regListener.remove();\n    }\n\n    // Create the toolbar menu of the auto club page in the fragment, not in the activity, which\n    // should be customized to have an imageview and textview underneath instead of setting icon\n    // by setting actionLayout(app:actionLayout in xml).\n    @Override\n    public void onCreateOptionsMenu(@NonNull Menu menu, @NonNull MenuInflater inflater) {\n        // Do something different from in the parent activity\n        //this.menu = menu;\n        //menu.getItem(0).setVisible(false);\n        //menu.getItem(1).setVisible(false);\n        if(currentPage == AUTOCLUB) {\n            View actionView = menu.getItem(0).getActionView();\n            ImageView imgEmblem = actionView.findViewById(R.id.img_action_emblem);\n            ProgressBar pbEmblem = actionView.findViewById(R.id.pb_emblem);\n\n            if(TextUtils.isEmpty(automaker)) {\n                menu.getItem(0).setVisible(false);\n                //actionView.setVisibility(View.INVISIBLE);\n            } else {\n                menu.getItem(0).setVisible(true);\n                actionView.setVisibility(View.VISIBLE);\n                setAutoMakerEmblem(pbEmblem, imgEmblem);\n                actionView.setOnClickListener(view -> onOptionsItemSelected(menu.getItem(0)));\n            }\n\n        } else super.onCreateOptionsMenu(menu, inflater);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        if(item.getItemId() == R.id.action_automaker_emblem) {\n            rotateAutoEmblem(item).start();\n            return true;\n        }\n        return false;\n    }\n\n    /*\n    @Override\n    public void notifyDialogDismissed(int position) {\n        log.i(\"Read Dialog dismissed:%s\", position);\n        // This problem is caused by RecyclerView Data modified in different thread.\n        // The best way is checking all data access. And a workaround is wrapping LinearLayoutManager.\n        //postingAdapter.notifyItemRemoved(position);\n        log.i(\"Item size: %s\", multiTypeItemList.size());\n        pagerAdapter.notifyItemChanged(currentPage);\n        //((BoardActivity)requireActivity()).addViewPager();\n    }\n\n     */\n\n    /*\n     * Implement QueryPaginationUtil.OnQueryPaginationCallback overriding the following 4 methods that\n     * performs to query posts with orderBy() and limit() conditioned up to the pagination number\n     * which is defined in BoardActivity.PAGINATION.\n     *\n     * getFirestQueryResult(): setPostQuery() has completed with queried posts up to the pagination number.\n     * getNextQueryResult(): setNextQuery() has completed with queried posts up to the pagination number.\n     * getLastQueryResult(); setNextQuery() has completed with queried posts under the pagination number.\n     * getQueryErrorResult(); callback invoked if any error has occurred while querying.\n     */\n\n    @Override\n    public void getFirstQueryResult(QuerySnapshot querySnapshot) {\n        //log.i(\"first query: %s, %s\", postingList.size(), querySnapshot.size());\n        //index = 0;\n        //multiTypeItemList.clear();\n        postingList.clear();\n        log.i(\"initial postingList: %s\", postingList.size());\n        if(querySnapshot.size() == 0) {\n            progbar.setVisibility(View.GONE);\n            binding.recyclerBoardPostings.setVisibility(View.GONE);\n            binding.tvEmptyView.setVisibility(View.VISIBLE);\n            return;\n        } else {\n            binding.recyclerBoardPostings.setVisibility(View.VISIBLE);\n            binding.tvEmptyView.setVisibility(View.GONE);\n        }\n\n        // Add DocumentSnapshot to List<DocumentSnapshot> which is paassed to RecyclerView.Adapter.\n        // The autoclub page should separately handle query and pagination to sorts out the document\n        // snapshot with given filters.\n        for(DocumentSnapshot document : querySnapshot) {\n            if (currentPage == AUTOCLUB) sortClubPost(document);\n            else {\n                postingList.add(document);\n                //multiTypeItemList.add(new MultiTypeItem(0, index, document));\n            }\n            //index++;\n        }\n\n        // Test Code: for pre-occupying the banner slot.\n        //addDummySlotForAds();\n        //multiTypeItemList.add(new MultiTypeItem(1));\n        postingAdapter.notifyItemRangeChanged(0, querySnapshot.size());\n        progbar.setVisibility(View.GONE);\n        isLoading = false;\n\n        // If the sorted posts are less than the pagination number, keep querying until it's up to\n        // the number. Manually update the adapter each time posts amount to the pagination number.\n        if(currentPage == AUTOCLUB) {\n            //if(multiTypeItemList.size() < PAGINATION) {\n            if(postingList.size() < PAGINATION) {\n                isLoading = true;\n                queryPagingUtil.setNextPostQuery();\n            }\n        }\n    }\n\n    @Override\n    public void getNextQueryResult(QuerySnapshot nextShots) {\n        //final int start = multiTypeItemList.size();\n        final int start = postingList.size();\n        for(DocumentSnapshot document : nextShots) {\n            if (currentPage == AUTOCLUB) sortClubPost(document);\n            else {\n                postingList.add(document);\n                //multiTypeItemList.add(new MultiTypeItem(0, index, document));\n            }\n            //index++;\n        }\n\n        // ADD THE AD BANNER: refactor required for the convenience's sake.\n        //multiTypeItemList.add(new MultiTypeItem(1));\n        postingAdapter.notifyItemRangeChanged(start, nextShots.size());\n        //binding.progbarBoardPaging.setVisibility(View.INVISIBLE);\n\n        // Keep querying if sorted posts are less than the pagination number. When it reaches the\n        // number, update the apdater.\n        if(currentPage == AUTOCLUB) {\n            //if(multiTypeItemList.size() < PAGINATION) {\n            if(postingList.size() < PAGINATION) {\n                isLoading = true;\n                queryPagingUtil.setNextPostQuery();\n            }//else postingAdapter.notifyDataSetChanged();\n        }\n        isLoading = false;\n    }\n\n    @Override\n    public void getLastQueryResult(QuerySnapshot lastShots) {\n        final int start = postingList.size();\n        //final int start = multiTypeItemList.size();\n        //int index = snapshotList.size();\n        for(DocumentSnapshot document : lastShots) {\n            if(currentPage == AUTOCLUB) sortClubPost(document);\n            else {\n                postingList.add(document);\n                //multiTypeItemList.add(new MultiTypeItem(0, index, document));\n            }\n            index++;\n        }\n        postingAdapter.notifyItemRangeChanged(start, lastShots.size());\n        //binding.progbarBoardPaging.setVisibility(View.GONE);\n        //isLoading = true; // Block the scroll listener from keeping querying.\n        binding.recyclerBoardPostings.removeOnScrollListener(scrollListener);\n\n        // On clicking the filter item on the autoclub page, if nothing has been posted, display\n        // the empty view.\n        if(currentPage == AUTOCLUB && postingList.size() == 0) {\n        //if(currentPage == AUTOCLUB && multiTypeItemList.size() == 0) {\n            //recyclerPostView.setEmptyView(binding.tvEmptyView);\n            //binding.recyclerBoardPostings.setEmptyView(binding.tvEmptyView);\n            binding.recyclerBoardPostings.setVisibility(View.GONE);\n            binding.tvEmptyView.setVisibility(View.VISIBLE);\n        } else {\n            binding.recyclerBoardPostings.setVisibility(View.VISIBLE);\n            binding.tvEmptyView.setVisibility(View.GONE);\n        }\n    }\n\n    @Override\n    public void getRemovedQueryResult(DocumentSnapshot doc) {\n        log.i(\"position: %s\", this.position);\n        postingList.remove(doc);\n        postingAdapter.notifyItemRemoved(position);\n        postingAdapter.notifyItemRangeChanged(position, postingList.size(), \"REMOVED\");\n    }\n\n    @Override\n    public void getModifiedQueryResult(DocumentSnapshot doc) {\n        log.i(\"added or edited\");\n    }\n\n    @Override\n    public void getQueryErrorResult(Exception e) {\n        progbar.setVisibility(View.GONE);\n        e.printStackTrace();\n        Toast.makeText(getActivity(), e.getMessage(), Toast.LENGTH_SHORT).show();\n        //isLoading = true;\n        binding.recyclerBoardPostings.removeOnScrollListener(scrollListener);\n    }\n\n    //Implement BoardPostingAdapter.OnRecyclerItemClickListener when an item is clicked.\n    //@SuppressWarnings({\"unchecked\", \"ConstantConditions\"})\n    @Override\n    public void onPostClicked(DocumentSnapshot snapshot, int position) {\n        // Initiate the task to query the board collection and the user collection.\n        // Show the dialog with the full screen. The container is android.R.id.content.\n        log.i(\"reset position: %s\", position);\n        this.position = position;\n        BoardReadFragment readPostFragment = new BoardReadFragment();\n        log.i(\"BoardReadFragment: %s\", readPostFragment.hashCode());\n\n        CustomPostingObject toObject = snapshot.toObject(CustomPostingObject.class);\n        assert toObject != null;\n        Bundle bundle = new Bundle();\n        bundle.putInt(\"tabPage\", currentPage);\n        bundle.putInt(\"position\", position);\n        bundle.putString(\"documentId\", snapshot.getId());\n        bundle.putParcelable(\"postingObj\", toObject);\n\n        readPostFragment.setArguments(bundle);\n        requireActivity().getSupportFragmentManager().beginTransaction()\n                .add(android.R.id.content, readPostFragment)\n                .addToBackStack(null)\n                .commit();\n\n        // Update the field of \"cnt_view\" increasing the number.\n        //DocumentReference docref = snapshot.getReference();\n        addViewCount(snapshot.getReference(), position);\n    }\n\n    //Invoked from the parent activity to pass checkbox changes made by OnCheckedChange() to make\n    //a new query w/ the Autoclub page.\n    public void setCheckBoxValueChange(ArrayList<String> autofilter){\n        this.autoFilter = autofilter;\n        for(String filter : autofilter) log.i(\"autofilter changed: %s\", filter);\n    }\n\n    // This method sorts out the autoclub posts based on the autofilter by removing a document out of\n    // the list if it has no autofilter field or its nested filter which can be accessed w/ the dot\n    // notation\n    private void sortClubPost(DocumentSnapshot snapshot) {\n        postingList.add(snapshot);\n        //multiTypeItemList.add(new MultiTypeItem(0, index, snapshot));\n        if(snapshot.get(\"auto_filter\") == null) postingList.remove(snapshot);\n        else {\n            for(String filter : autoFilter) {\n                if ((snapshot.get(\"auto_filter.\" + filter) == null)) {\n                    postingList.remove(snapshot);\n                    break;\n                }\n            }\n        }\n    }\n\n    // RecyclerView.OnScrollListener is an abstract class to receive messages when a scrolling event\n    // has occurred on that RecyclerView, which has 2 abstract methods of onScrollStateChanged() and\n    // onScrolled(); the former is to be invoked when RecyclerView's scroll state changes and the\n    // latter invoked when the RecyclerView has been scrolled.\n    //private RecyclerView.OnScrollListener setRecyclerViewScrollListener() {\n    private final RecyclerView.OnScrollListener scrollListener = new RecyclerView.OnScrollListener(){\n        /* Callback to be invoked when the RecyclerView has been scrolled, which will be called\n         * right after the scroll has completed. This callback will also be called if visible\n         * item range changes after a layout calculation, in which dx and dy will be 0.\n         * @param recyclerView being scrolled\n         * @param dx The amount of horizontal scroll\n         * @param dy The amount of vertical scroll\n         */\n        @Override\n        public void onScrolled(@NonNull RecyclerView recyclerView, int dx, int dy) {\n            super.onScrolled(recyclerView, dx, dy);\n            fabWrite.setAlpha(0.8f);\n            //WrapContentLinearLayoutManager layout = (WrapContentLinearLayoutManager)recyclerView.getLayoutManager();\n            LinearLayoutManager layout = (LinearLayoutManager)recyclerView.getLayoutManager();\n            if (layout != null) {\n                int firstVisibleProductPosition = layout.findFirstVisibleItemPosition();\n                int visiblePostCount = layout.getChildCount();\n                int totalPostCount = layout.getItemCount();\n                //log.i(\"totalPostCount: %s, %s, %s\", firstVisibleProductPosition, visiblePostCount, totalPostCount);\n\n                if (!isLoading && (firstVisibleProductPosition + visiblePostCount == totalPostCount)) {\n                    //isScrolling = false;\n                    isLoading = true;\n                    //if(currentPage != AUTOCLUB) pbPaging.setVisibility(View.VISIBLE);\n                    // If the totalPostCount is less than PAGINATION, setNextQuery will\n                    // return null value, which results in an error as in Notification board. Accrodingly,\n                    // a condition has to be added to prevent setNextQuery().\n                    if(currentPage != AUTOCLUB && totalPostCount >= PAGINATION) {\n                        //binding.progbarBoardPaging.setVisibility(View.VISIBLE);\n                        queryPagingUtil.setNextPostQuery();\n                    }\n\n                    //if(currentPage != AUTOCLUB) queryPostSnapshot(currentPage);\n                    //else if(!isLastPage) clubRepo.setNextQuery();\n                }\n            }\n        }\n\n    };\n\n\n\n    /*\n     * Check if a user is the post's owner or has read the post before in order to increate the view\n     * count. In order to do so, get the user id from the internal storage and from the post as well.\n     * Get the user id and query the \"viewers\" sub-collection to check if the user id exists in the\n     * documents, which means whether the user has read the post before. If so, do not increase\n     * the view count. Otherwise, add the user id to the \"viewers\" collection and increase the\n     * view count;\n     */\n    private void addViewCount(DocumentReference docref, int pos) {\n        try(FileInputStream fis = Objects.requireNonNull(requireActivity()).openFileInput(\"userId\");\n            BufferedReader br = new BufferedReader(new InputStreamReader(fis))) {\n            final String viewerId = br.readLine();\n\n            //CollectionReference subCollection = docref.collection(\"viewers\");\n            DocumentReference viewerRef = docref.collection(\"viewers\").document(viewerId);\n            firestore.runTransaction(transaction -> {\n                DocumentSnapshot viewershot = transaction.get(viewerRef);\n                if(!viewershot.exists()) {\n                    docref.update(\"cnt_view\", FieldValue.increment(1));\n                    Map<String, Object> data = new HashMap<>();\n                    data.put(\"timestamp\", FieldValue.serverTimestamp());\n                    data.put(\"viewer_ip\", \"192.0.0.255\"); // code for getting the viewer id required.\n                    docref.collection(\"viewers\").document(viewerId).set(data, SetOptions.merge())\n                            .addOnSuccessListener(aVoid -> {\n                                docref.get().addOnSuccessListener(doc ->\n                                    postingAdapter.notifyItemChanged(pos, doc.getLong(\"cnt_view\"))\n                                );\n                            }).addOnFailureListener(Throwable::printStackTrace);\n                }\n                return null;\n            });\n            /*\n            subCollection.document(viewerId).get().addOnSuccessListener(snapshot -> {\n                // In case the user has not read the post before and adoes not exists in the \"viewers\"\n                // collection\n                if(!snapshot.exists()) {\n                  docref.update(\"cnt_view\", FieldValue.increment(1));\n                  // Set timestamp and the user ip with the user id used as the document id.\n                  Map<String, Object> viewerData = new HashMap<>();\n\n                  viewerData.put(\"timestamp\", FieldValue.serverTimestamp());\n                  viewerData.put(\"viewer_ip\", \"\");\n\n                  subCollection.document(viewerId).set(viewerData).addOnSuccessListener(aVoid -> {\n                      // Listener to events for local changes, which is notified with the new data\n                      // before the data is sent to the backend.\n                      docref.get().addOnSuccessListener(data -> {\n                          if(data.exists())\n                              // Partial binding to BoardPostingAdapter to update the view count in\n                              // the post document.\n                              postingAdapter.notifyItemChanged(pos, data.getLong(\"cnt_view\"));\n                      }).addOnFailureListener(Exception::printStackTrace);\n                  });\n                }\n            });\n            */\n\n        } catch(IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    // Attemp to retrieve the emblem uri from Firestore only when an auto maker is provided. For this\n    // reason, the method should be placed at the end of createAutoFilterCheckBox() which receives\n    // auto data as json type.\n    private void setAutoMakerEmblem(ProgressBar pb, ImageView imgview) {\n        // Make the progressbar visible until getting the emblem from Firetore\n        pb.setVisibility(View.VISIBLE);\n        firestore.collection(\"autodata\").document(automaker).get().addOnSuccessListener(doc -> {\n            String emblem = doc.getString(\"auto_emblem\");\n            if(TextUtils.isEmpty(emblem)) return;\n            else {\n                Uri uri = Uri.parse(emblem);\n                final int x = imgview.getMeasuredWidth();\n                final int y = imgview.getMeasuredHeight();\n                imgutil.applyGlideToEmblem(uri, x, y, imgview);\n            }\n\n            pb.setVisibility(View.GONE);\n\n        });\n\n        /*\n        //firestore.collection(\"autodata\").whereEqualTo(\"auto_maker\", automaker).get()\n        firestore.collection(\"autodata\").whereEqualTo(FieldPath.documentId(), automaker).get()\n                .addOnSuccessListener(queires -> {\n                    for(QueryDocumentSnapshot autoshot : queires) {\n                        String emblem = autoshot.getString(\"auto_emblem\");\n                        // Empty Check. Refactor should be taken to show an empty icon, instead.\n                        if(TextUtils.isEmpty(emblem)) return;\n                        else {\n                            Uri uri = Uri.parse(emblem);\n                            final int x = imgview.getMeasuredWidth();\n                            final int y = imgview.getMeasuredHeight();\n                            imgutil.applyGlideToEmblem(uri, x, y, imgview);\n                        }\n\n                        pb.setVisibility(View.GONE);\n                        break;\n                    }\n                }).addOnFailureListener(e -> {\n                    pb.setVisibility(View.GONE);\n                    e.printStackTrace();\n                });\n\n         */\n    }\n    private ObjectAnimator rotateAutoEmblem(MenuItem item) {\n        ObjectAnimator rotation = ObjectAnimator.ofFloat(item.getActionView(), \"rotationY\", 0.0f, 360f);\n        rotation.setDuration(500);\n        rotation.setInterpolator(new AccelerateDecelerateInterpolator());\n        // Use AnimatorListenerAdapter to take callback methods seletively.\n        rotation.addListener(new AnimatorListenerAdapter(){\n            @Override\n            public void onAnimationEnd(Animator animation, boolean isReverse) {\n                rotation.cancel();\n                String sorting = (isViewOrder)? getString(R.string.board_autoclub_sort_time) :\n                        getString(R.string.board_autoclub_sort_view);\n                TextView tvSorting = item.getActionView().findViewById(R.id.tv_sorting_order);\n                tvSorting.setText(sorting);\n                isViewOrder = !isViewOrder;\n            }\n        });\n\n        return rotation;\n    }\n\n    public static class MultiTypeItem {\n        DocumentSnapshot snapshot;\n        int index;\n        int viewType;\n\n        public MultiTypeItem(int viewType, int index, DocumentSnapshot snapshot) {\n            this.snapshot = snapshot;\n            this.viewType = viewType;\n            this.index = index;\n        }\n\n        public MultiTypeItem(int viewType){\n            this.viewType = viewType;\n        }\n        public DocumentSnapshot getItemSnapshot() {\n            return snapshot;\n        }\n        public int getViewType() {\n            return viewType;\n        }\n        public int getItemIndex() {\n            return index;\n        }\n    }\n\n    // Wrapper class to throw java.lang.IndexOutOfBoundsException: Inconsistency detected.\n    // Invalid view holder adapter positionPostViewHolder\n    private static class WrapContentLinearLayoutManager extends LinearLayoutManager {\n        // Constructor\n        public WrapContentLinearLayoutManager(Context context) {\n            super(context, LinearLayoutManager.VERTICAL, false);\n        }\n\n        @Override\n        public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {\n            try {\n                super.onLayoutChildren(recycler, state);\n            } catch(IndexOutOfBoundsException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    /*\n    // Callback implemented by QueryClubPostingUtil.setPostingQuery() when initiating query for\n    // the autoclub post. Receiving a result querysnapshot, categorize each snapshot by type, then\n    // update the postshotList. To get the club list, filter the postshot list with the autofilter\n    // using sortAutoClubPost(), adding a filtered snapshot to the club list. If the club list is\n    // less than the pagination number, keep querying posts to add more club posts, calling\n    // QueryClubPostingUtil.setNextQuery().\n    @Override\n    public void setClubQuerySnapshot(QuerySnapshot snapshots) {\n        clubshotList.clear();\n        if(snapshots.size() == 0) {\n            recyclerPostView.setEmptyView(binding.tvEmptyView);\n            return;\n        }\n\n        for(DocumentChange documentChange : snapshots.getDocumentChanges()) {\n            switch(documentChange.getType()) {\n                case ADDED:\n                    DocumentSnapshot addSnapshot = documentChange.getDocument();\n                    postshotList.add(addSnapshot);\n                    sortAutoClubPost(addSnapshot);\n                    break;\n\n                case MODIFIED:\n                    DocumentSnapshot modifySnapshot = documentChange.getDocument();\n                    for(int i = 0; i < postshotList.size(); i++) {\n                        DocumentSnapshot snapshot = postshotList.get(i);\n                        if(snapshot.getId().equals(modifySnapshot.getId())) {\n                            postshotList.remove(snapshot);\n                            postshotList.add(i, modifySnapshot);\n                            break;\n                        }\n                    }\n\n                    sortAutoClubPost(modifySnapshot);\n                    break;\n\n                case REMOVED:\n                    DocumentSnapshot removeSnapshot = documentChange.getDocument();\n                    for(int i = 0; i < postshotList.size(); i++) {\n                        DocumentSnapshot snapshot = postshotList.get(i);\n                        if(snapshot.getId().equals(removeSnapshot.getId())) {\n                            postshotList.remove(snapshot);\n                            break;\n                        }\n                    }\n\n                    sortAutoClubPost(removeSnapshot);\n                    break;\n            }\n        }\n\n        if(snapshots.size() < Constants.PAGINATION) {\n            isLastPage = true;\n            postingAdapter.notifyDataSetChanged();\n        } else {\n            isLastPage = false;\n            if(clubshotList.size() < Constants.PAGINATION) clubRepo.setNextQuery();\n            else postingAdapter.notifyDataSetChanged();\n        }\n\n        pbLoading.setVisibility(View.GONE);\n    }\n\n    // This method sorts out the autoclub posts based on the autofilter by removing a document out of\n    // the list if it has no autofilter field or its nested filter which can be accessed w/ the dot\n    // notation\n    private void sortAutoClubPost(DocumentSnapshot snapshot) {\n        clubshotList.add(snapshot);\n        if(snapshot.get(\"auto_filter\") == null) clubshotList.remove(snapshot);\n        else {\n            for(String filter : autoFilter) {\n                if ((snapshot.get(\"auto_filter.\" + filter) == null)) {\n                    clubshotList.remove(snapshot);\n                    break;\n                }\n            }\n        }\n    }\n\n    // Query the general board except for the club board.\n    private void queryPostSnapshot(int page) {\n        postRepo.setPostingQuery(page);\n\n        // Notified of documentsnapshot from the livedata\n        PostingBoardLiveData postLiveData = postingModel.getPostingBoardLiveData();\n        if(postLiveData != null) {\n            postLiveData.observe(getViewLifecycleOwner(), operation -> {\n                log.i(\"operation thread: %s\", Thread.currentThread());\n\n                int type = operation.getType();\n                DocumentSnapshot postshot = operation.getDocumentSnapshot();\n                // Add a post only if the post_general field is set to true at the general board.\n                switch(type) {\n                    case 0: // ADDED\n                        log.i(\"Added: %s, %s\", currentPage, postshot.getString(\"post_title\"));\n                        postshotList.add(postshot);\n                        break;\n\n                    case 1: // MODIFIED\n                        log.i(\"Modified: %s, %s\", currentPage, postshot.getString(\"post_title\"));\n                        for(int i = 0; i < postshotList.size(); i++) {\n                            DocumentSnapshot snapshot = postshotList.get(i);\n                            if(snapshot.getId().equals(postshot.getId())) {\n                                postshotList.remove(snapshot);\n                                postshotList.add(i, postshot);\n                                break;\n                            }\n                        }\n\n                        break;\n\n                    case 2: // REMOVED\n                        log.i(\"Removed: %s, %s\", currentPage, postshot.getString(\"post_title\"));\n                        for(int i = 0; i < postshotList.size(); i++) {\n                            DocumentSnapshot snapshot = postshotList.get(i);\n                            if(snapshot.getId().equals(postshot.getId())) {\n                                log.i(\"snapshot removed: %s\", snapshot.getString(\"post_title\"));\n                                postshotList.remove(snapshot);\n                                break;\n                            }\n\n                        }\n\n                        break;\n                }\n\n                postingAdapter.notifyDataSetChanged();\n            });\n\n            pbLoading.setVisibility(View.GONE);\n        }\n    }\n    */\n}\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/silverback/carman/fragments/BoardPagerFragment.java b/app/src/main/java/com/silverback/carman/fragments/BoardPagerFragment.java
--- a/app/src/main/java/com/silverback/carman/fragments/BoardPagerFragment.java	
+++ b/app/src/main/java/com/silverback/carman/fragments/BoardPagerFragment.java	
@@ -38,7 +38,6 @@
 import com.google.firebase.firestore.FieldValue;
 import com.google.firebase.firestore.FirebaseFirestore;
 import com.google.firebase.firestore.ListenerRegistration;
-import com.google.firebase.firestore.MetadataChanges;
 import com.google.firebase.firestore.QuerySnapshot;
 import com.google.firebase.firestore.SetOptions;
 import com.google.firebase.firestore.Source;
@@ -88,7 +87,7 @@
         QueryPostPaginationUtil.OnQueryPaginationCallback,
         //BoardReadFragment.OnDialogDismissListener,
         //QueryClubPostingUtil.OnPaginationListener,
-        BoardPostingAdapter.OnRecyclerItemClickListener {
+        BoardPostingAdapter.OnRecyclerAdapterListener {
 
     // Logging
     private static final LoggingHelper log = LoggingHelperFactory.create(BoardPagerFragment.class);
@@ -97,7 +96,7 @@
     //private List<MultiTypeItem> multiTypeItemList;
     private List<DocumentSnapshot> postingList;
 
-    private FirebaseFirestore firestore;
+    private FirebaseFirestore mDB;
     private ListenerRegistration regListener;
     private CollectionReference colRef;
     private Source source;
@@ -122,7 +121,7 @@
     private String automaker;
     private int currentPage;
     private boolean isViewOrder;
-    private boolean isLoading; // to block recyclerview from scrolling while loading posts.
+    private boolean isQuerying; // to block recyclerview from scrolling while loading posts.
     private int index;
     private int position;
     //private boolean isLastPage;
@@ -161,17 +160,18 @@
         // Instantiate objects.
         //multiTypeItemList = new ArrayList<>();
         postingList = new ArrayList<>();
-        firestore = FirebaseFirestore.getInstance();
+        mDB = FirebaseFirestore.getInstance();
         // Instantiate the query and pagination util class and create the RecyclerView adapter to
         // show the posting list.
         postingAdapter = new BoardPostingAdapter(postingList, this);
         //postingAdapter = new BoardPostingAdapter(multiTypeItemList, this);
-        queryPagingUtil = new QueryPostPaginationUtil(firestore, this);
-        colRef = firestore.collection("user_post");
+        queryPagingUtil = new QueryPostPaginationUtil(mDB, this);
+        colRef = mDB.collection("user_post");
         //source = (source == null) ? Source.SERVER : Source.CACHE;
-        if(currentPage == AUTOCLUB) queryPagingUtil.setAutoclubOrder(isViewOrder);
+
+        if(currentPage == AUTOCLUB) queryPagingUtil.setAutoClubOrder(isViewOrder);
         regListener = queryPagingUtil.setPostQuery(colRef, currentPage);
-        isLoading = true;
+        isQuerying = true;
 
         /*
         regListener = colRef.addSnapshotListener(MetadataChanges.INCLUDE, (q, e) -> {
@@ -301,6 +301,13 @@
     public void onStop() {
         super.onStop();
         if(regListener != null) regListener.remove();
+        binding.recyclerBoardPostings.removeOnScrollListener(scrollListener);
+    }
+
+    @Override
+    public void onDestroyView(){
+        super.onDestroyView();
+        binding = null;
     }
 
     // Create the toolbar menu of the auto club page in the fragment, not in the activity, which
@@ -364,6 +371,160 @@
      * getQueryErrorResult(); callback invoked if any error has occurred while querying.
      */
 
+    @Override
+    public void onPostItemClicked(DocumentSnapshot snapshot, int position) {
+        // Initiate the task to query the board collection and the user collection.
+        // Show the dialog with the full screen. The container is android.R.id.content.
+        log.i("reset position: %s", position);
+        this.position = position;
+        BoardReadFragment readPostFragment = new BoardReadFragment();
+        log.i("BoardReadFragment: %s", readPostFragment.hashCode());
+
+        CustomPostingObject toObject = snapshot.toObject(CustomPostingObject.class);
+        assert toObject != null;
+        Bundle bundle = new Bundle();
+        bundle.putInt("tabPage", currentPage);
+        bundle.putInt("position", position);
+        bundle.putString("documentId", snapshot.getId());
+        bundle.putParcelable("postingObj", toObject);
+
+        readPostFragment.setArguments(bundle);
+        requireActivity().getSupportFragmentManager().beginTransaction()
+                .add(android.R.id.content, readPostFragment)
+                .addToBackStack(null)
+                .commit();
+
+        // Update the field of "cnt_view" increasing the number.
+        //DocumentReference docref = snapshot.getReference();
+        addViewCount(snapshot.getReference(), position);
+    }
+
+    @Override
+    public void onRecyclerUpdateDone() {
+        //binding.recyclerBoardPostings.smoothScrollToPosition(0);
+        postingAdapter.notifyItemRangeChanged(0, postingList.size(), "indexing");
+    }
+
+    @Override
+    public void getFirstQueryResult(QuerySnapshot querySnapshot) {
+        postingList.clear();
+        addPostByCategory(querySnapshot, false);
+        isQuerying = false;
+    }
+
+    @Override
+    public void getNextQueryResult(QuerySnapshot nextShots) {
+        addPostByCategory(nextShots, false);
+        isQuerying = false;
+    }
+
+    @Override
+    public void getLastQueryResult(QuerySnapshot lastShots) {
+        log.i("Last Query");
+        addPostByCategory(lastShots, true);
+        isQuerying = true;
+    }
+
+    /*
+    @Override
+    public void getRemovedQueryResult(DocumentSnapshot doc) {
+
+    }
+
+    @Override
+    public void getModifiedQueryResult(DocumentSnapshot doc) {
+
+    }
+
+     */
+
+    @Override
+    public void getQueryErrorResult(Exception e) {
+        progbar.setVisibility(View.GONE);
+        e.printStackTrace();
+        Toast.makeText(getActivity(), e.getMessage(), Toast.LENGTH_SHORT).show();
+        isQuerying = true;
+        binding.recyclerBoardPostings.removeOnScrollListener(scrollListener);
+    }
+
+    private void addPostByCategory(QuerySnapshot querySnapshot, boolean isLast) {
+        for(DocumentSnapshot doc : querySnapshot) {
+            if(currentPage == AUTOCLUB) {
+                if(autoFilter == null || autoFilter.size() == 0) break;
+                CustomPostingObject toObject = doc.toObject(CustomPostingObject.class);
+                if(toObject == null) return;
+                ArrayList<String> filters = new ArrayList<>(toObject.getAutofilter());
+                if(filters.containsAll(autoFilter)) postingList.add(doc);
+            } else postingList.add(doc);
+        }
+
+        if(currentPage == AUTOCLUB) {
+            if (!isLast && postingList.size() < PAGINATION) {
+                isQuerying = true;
+                queryPagingUtil.setNextPostQuery();
+                return;
+            } else {
+                progbar.setVisibility(View.GONE);
+                postingAdapter.submitPostList(postingList);
+
+            }
+        } else {
+            progbar.setVisibility(View.GONE);
+            postingAdapter.submitPostList(postingList);
+        }
+
+
+        // Visibility control relying on whether the posting list exists. Refactor required.
+        if(isLast && postingList.size() == 0) {
+            progbar.setVisibility(View.GONE);
+            binding.recyclerBoardPostings.setVisibility(View.GONE);
+            binding.tvEmptyView.setVisibility(View.VISIBLE);
+        } else {
+            binding.recyclerBoardPostings.setVisibility(View.VISIBLE);
+            binding.tvEmptyView.setVisibility(View.GONE);
+        }
+
+    }
+
+    public void resetAutoFilter(ArrayList<String> autoFitler) {
+        // Revert the visibility which has been previously set with no data.
+        if(postingList.size() == 0) {
+            binding.recyclerBoardPostings.setVisibility(View.VISIBLE);
+            binding.tvEmptyView.setVisibility(View.GONE);
+        }
+
+        this.autoFilter = autoFitler;
+        isQuerying = true;
+        String field = (isViewOrder) ? "cnt_view" : "timestamp";
+        queryPagingUtil.setAutofilterQuery(field);
+    }
+
+    private ObjectAnimator rotateAutoEmblem(MenuItem item) {
+        ObjectAnimator rotation = ObjectAnimator.ofFloat(item.getActionView(), "rotationY", 0.0f, 360f);
+        rotation.setDuration(500);
+        rotation.setInterpolator(new AccelerateDecelerateInterpolator());
+        // Use AnimatorListenerAdapter to take callback methods seletively.
+        rotation.addListener(new AnimatorListenerAdapter(){
+            @Override
+            public void onAnimationEnd(Animator animation, boolean isReverse) {
+                /*
+                rotation.cancel();
+                String sorting = (isViewOrder)? getString(R.string.board_autoclub_sort_time) :
+                        getString(R.string.board_autoclub_sort_view);
+                TextView tvSorting = item.getActionView().findViewById(R.id.tv_sorting_order);
+                tvSorting.setText(sorting);
+                isViewOrder = !isViewOrder;
+                 */
+                resetAutoFilter(autoFilter);
+                rotation.cancel();
+
+            }
+        });
+
+        return rotation;
+    }
+
+    /*
     @Override
     public void getFirstQueryResult(QuerySnapshot querySnapshot) {
         //log.i("first query: %s, %s", postingList.size(), querySnapshot.size());
@@ -398,14 +559,14 @@
         //multiTypeItemList.add(new MultiTypeItem(1));
         postingAdapter.notifyItemRangeChanged(0, querySnapshot.size());
         progbar.setVisibility(View.GONE);
-        isLoading = false;
+        isQuerying = false;
 
         // If the sorted posts are less than the pagination number, keep querying until it's up to
         // the number. Manually update the adapter each time posts amount to the pagination number.
         if(currentPage == AUTOCLUB) {
             //if(multiTypeItemList.size() < PAGINATION) {
             if(postingList.size() < PAGINATION) {
-                isLoading = true;
+                isQuerying = true;
                 queryPagingUtil.setNextPostQuery();
             }
         }
@@ -434,11 +595,11 @@
         if(currentPage == AUTOCLUB) {
             //if(multiTypeItemList.size() < PAGINATION) {
             if(postingList.size() < PAGINATION) {
-                isLoading = true;
+                isQuerying = true;
                 queryPagingUtil.setNextPostQuery();
             }//else postingAdapter.notifyDataSetChanged();
         }
-        isLoading = false;
+        isQuerying = false;
     }
 
     @Override
@@ -494,9 +655,10 @@
         //isLoading = true;
         binding.recyclerBoardPostings.removeOnScrollListener(scrollListener);
     }
-
+    */
     //Implement BoardPostingAdapter.OnRecyclerItemClickListener when an item is clicked.
     //@SuppressWarnings({"unchecked", "ConstantConditions"})
+    /*
     @Override
     public void onPostClicked(DocumentSnapshot snapshot, int position) {
         // Initiate the task to query the board collection and the user collection.
@@ -525,6 +687,8 @@
         addViewCount(snapshot.getReference(), position);
     }
 
+     */
+
     //Invoked from the parent activity to pass checkbox changes made by OnCheckedChange() to make
     //a new query w/ the Autoclub page.
     public void setCheckBoxValueChange(ArrayList<String> autofilter){
@@ -574,9 +738,9 @@
                 int totalPostCount = layout.getItemCount();
                 //log.i("totalPostCount: %s, %s, %s", firstVisibleProductPosition, visiblePostCount, totalPostCount);
 
-                if (!isLoading && (firstVisibleProductPosition + visiblePostCount == totalPostCount)) {
+                if (!isQuerying && (firstVisibleProductPosition + visiblePostCount == totalPostCount)) {
                     //isScrolling = false;
-                    isLoading = true;
+                    isQuerying = true;
                     //if(currentPage != AUTOCLUB) pbPaging.setVisibility(View.VISIBLE);
                     // If the totalPostCount is less than PAGINATION, setNextQuery will
                     // return null value, which results in an error as in Notification board. Accrodingly,
@@ -611,7 +775,7 @@
 
             //CollectionReference subCollection = docref.collection("viewers");
             DocumentReference viewerRef = docref.collection("viewers").document(viewerId);
-            firestore.runTransaction(transaction -> {
+            mDB.runTransaction(transaction -> {
                 DocumentSnapshot viewershot = transaction.get(viewerRef);
                 if(!viewershot.exists()) {
                     docref.update("cnt_view", FieldValue.increment(1));
@@ -664,7 +828,7 @@
     private void setAutoMakerEmblem(ProgressBar pb, ImageView imgview) {
         // Make the progressbar visible until getting the emblem from Firetore
         pb.setVisibility(View.VISIBLE);
-        firestore.collection("autodata").document(automaker).get().addOnSuccessListener(doc -> {
+        mDB.collection("autodata").document(automaker).get().addOnSuccessListener(doc -> {
             String emblem = doc.getString("auto_emblem");
             if(TextUtils.isEmpty(emblem)) return;
             else {
@@ -703,25 +867,7 @@
 
          */
     }
-    private ObjectAnimator rotateAutoEmblem(MenuItem item) {
-        ObjectAnimator rotation = ObjectAnimator.ofFloat(item.getActionView(), "rotationY", 0.0f, 360f);
-        rotation.setDuration(500);
-        rotation.setInterpolator(new AccelerateDecelerateInterpolator());
-        // Use AnimatorListenerAdapter to take callback methods seletively.
-        rotation.addListener(new AnimatorListenerAdapter(){
-            @Override
-            public void onAnimationEnd(Animator animation, boolean isReverse) {
-                rotation.cancel();
-                String sorting = (isViewOrder)? getString(R.string.board_autoclub_sort_time) :
-                        getString(R.string.board_autoclub_sort_view);
-                TextView tvSorting = item.getActionView().findViewById(R.id.tv_sorting_order);
-                tvSorting.setText(sorting);
-                isViewOrder = !isViewOrder;
-            }
-        });
 
-        return rotation;
-    }
 
     public static class MultiTypeItem {
         DocumentSnapshot snapshot;
Index: app/src/main/java/com/silverback/carman/fragments/BoardReadFragment.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n * Copyright (C) 2012 The Carman Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.silverback.carman.fragments;\n\nimport static android.content.Context.INPUT_METHOD_SERVICE;\nimport static com.silverback.carman.BoardActivity.AUTOCLUB;\nimport static com.silverback.carman.BoardActivity.PAGING_COMMENT;\n\nimport android.app.Dialog;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.SharedPreferences;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.text.SpannableString;\nimport android.text.SpannableStringBuilder;\nimport android.text.Spanned;\nimport android.text.TextUtils;\nimport android.text.style.AbsoluteSizeSpan;\nimport android.view.LayoutInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.inputmethod.InputMethodManager;\nimport android.widget.CompoundButton;\nimport android.widget.ImageView;\nimport android.widget.LinearLayout;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport androidx.activity.result.ActivityResult;\nimport androidx.activity.result.ActivityResultLauncher;\nimport androidx.activity.result.contract.ActivityResultContracts;\nimport androidx.annotation.NonNull;\nimport androidx.appcompat.widget.Toolbar;\nimport androidx.constraintlayout.widget.ConstraintLayout;\nimport androidx.constraintlayout.widget.ConstraintSet;\nimport androidx.core.content.ContextCompat;\nimport androidx.fragment.app.DialogFragment;\nimport androidx.fragment.app.FragmentManager;\nimport androidx.lifecycle.ViewModelProvider;\nimport androidx.preference.PreferenceManager;\nimport androidx.recyclerview.widget.DefaultItemAnimator;\nimport androidx.recyclerview.widget.LinearLayoutManager;\n\nimport com.bumptech.glide.Glide;\nimport com.bumptech.glide.load.engine.DiskCacheStrategy;\nimport com.google.android.material.appbar.AppBarLayout;\nimport com.google.android.material.snackbar.Snackbar;\nimport com.google.firebase.firestore.DocumentReference;\nimport com.google.firebase.firestore.DocumentSnapshot;\nimport com.google.firebase.firestore.FieldValue;\nimport com.google.firebase.firestore.FirebaseFirestore;\nimport com.google.firebase.firestore.ListenerRegistration;\nimport com.google.firebase.firestore.QuerySnapshot;\nimport com.google.firebase.firestore.Transaction;\nimport com.google.firebase.storage.FirebaseStorage;\nimport com.silverback.carman.BoardActivity;\nimport com.silverback.carman.R;\nimport com.silverback.carman.SettingActivity;\nimport com.silverback.carman.adapters.BoardCommentAdapter;\nimport com.silverback.carman.adapters.BoardReplyAdapter;\nimport com.silverback.carman.databinding.FragmentBoardReadBinding;\nimport com.silverback.carman.logs.LoggingHelper;\nimport com.silverback.carman.logs.LoggingHelperFactory;\nimport com.silverback.carman.utils.ApplyImageResourceUtil;\nimport com.silverback.carman.utils.Constants;\nimport com.silverback.carman.utils.CustomPostingObject;\nimport com.silverback.carman.utils.QueryPostPaginationUtil;\nimport com.silverback.carman.utils.RecyclerDividerUtil;\nimport com.silverback.carman.viewmodels.FragmentSharedModel;\nimport com.silverback.carman.viewmodels.ImageViewModel;\n\nimport java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * This dialogfragment reads a post content in the full size when clicking  an item recycled in\n * BoardPagerFragment.\n */\npublic class BoardReadFragment extends DialogFragment implements\n        View.OnClickListener,\n        Toolbar.OnMenuItemClickListener,\n        CompoundButton.OnCheckedChangeListener,\n        BoardCommentAdapter.CommentAdapterListener,\n        QueryPostPaginationUtil.OnQueryPaginationCallback {\n        //QueryCommentPagingUtil.OnQueryPaginationCallback {\n\n    private static final LoggingHelper log = LoggingHelperFactory.create(BoardReadFragment.class);\n\n    // Constants\n    private static final int STATE_COLLAPSED = 0;\n    private static final int STATE_EXPANDED = 1;\n    private static final int STATE_IDLE = 2;\n\n    // Objects\n    private Context context;\n    private CustomPostingObject obj;\n    //private PostingBoardRepository postRepo;\n    //private PostingBoardViewModel postingModel;\n    //private PostingClubRepository pagingUtil;\n    //private OnDialogDismissListener dialogDismissListener;\n    private ListenerRegistration regListener;\n    //private QueryCommentPagingUtil queryCommentPagingUtil;\n    private QueryPostPaginationUtil queryPaginationUtil;\n    private SharedPreferences mSettings;\n    //private OnEditModeListener mListener;\n    private FirebaseFirestore mDB;\n    private FirebaseStorage storage;\n    private DocumentReference postRef;\n    private ApplyImageResourceUtil imgUtil;\n    private ImageViewModel imgViewModel;\n    private FragmentSharedModel sharedModel;\n    private BoardCommentAdapter commentAdapter;\n    private String documentId;\n    private String viewerId;\n    private ArrayList<String> uriStringList, autofilter;\n    private List<DocumentSnapshot> commentShotList;\n    private InputMethodManager imm;\n    //private ListenerRegistration commentListener;\n    //private List<CharSequence> autoclub;\n\n    // UIs\n    private FragmentBoardReadBinding binding;\n    // Fields\n    private SpannableStringBuilder autoTitle;\n    private String tabTitle;\n    private String userPic;\n    private int tabPage, position;\n    //private int position; // item poistion in the recyclerview.\n    private int checkedPos;\n    private int appbarOffset;\n    private int cntComment, cntCompathy;\n    private boolean isCommentVisible;\n    private boolean hasCompathy;\n    //private boolean isLoading;\n\n    // Interface for notifying BoardActivity of pressing the edit menu in the toolbar which is visible\n    // only when a user reads his/her own post\n    /*\n    public interface OnEditModeListener {\n        void onEditClicked(Bundle bundle);\n    }\n    // Interface for listening to BoardActivity at the lifecycle of onAttachFragment.\n    public void setEditModeListener(OnEditModeListener listener) {\n        mListener = listener;\n    }\n     */\n    // Constructor default.\n    public BoardReadFragment() {\n        // Required empty public constructor\n    }\n\n    final ActivityResultLauncher<Intent> activityResultLauncher = registerForActivityResult(\n                new ActivityResultContracts.StartActivityForResult(), this::getActivityResultCallback);\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        if(getArguments() != null) {\n            obj = getArguments().getParcelable(\"postingObj\");\n            assert obj != null;\n            tabPage = getArguments().getInt(\"tabPage\");\n            position = getArguments().getInt(\"position\");\n            documentId = getArguments().getString(\"documentId\");\n            cntComment = obj.getCntComment();\n            cntCompathy = obj.getCntCompahty();\n            if(obj.getPostImages() != null) uriStringList = new ArrayList<>(obj.getPostImages());\n            if(obj.getAutofilter() != null) autofilter = new ArrayList<>(obj.getAutofilter());\n        }\n\n        // Get the viewer id for checking whether the post owner is the viewer\n        try(FileInputStream fis = requireActivity().openFileInput(\"userId\");\n            BufferedReader br = new BufferedReader(new InputStreamReader(fis))){\n            viewerId = br.readLine();\n        } catch(IOException e) {e.printStackTrace();}\n\n        this.context = requireContext();\n        mDB = FirebaseFirestore.getInstance();\n        storage = FirebaseStorage.getInstance();\n        mSettings = PreferenceManager.getDefaultSharedPreferences(context);\n        imgUtil = new ApplyImageResourceUtil(context);\n        imm = (InputMethodManager)context.getSystemService(INPUT_METHOD_SERVICE);\n\n        //queryCommentPagingUtil = new QueryCommentPagingUtil(firestore, this);\n        queryPaginationUtil = new QueryPostPaginationUtil(mDB, this);\n        commentShotList = new ArrayList<>();\n        commentAdapter = new BoardCommentAdapter(getContext(), commentShotList, viewerId, this);\n\n        // Get the current document reference which should be shared in the fragment.\n        // Initially, attach SnapshotListener to have the comment collection updated, then remove\n        // the listener to prevent connecting to the server. Instead`, update the collection using\n        // Source.Cache.\n        postRef = mDB.collection(\"user_post\").document(documentId);\n        queryPaginationUtil.setCommentQuery(postRef, \"timestamp\");\n    }\n\n    @Override\n    public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container,\n                             Bundle savedInstanceState) {\n\n        binding = FragmentBoardReadBinding.inflate(inflater);\n        // Set the stand-alone toolabr which works in the same way that the action bar does in most\n        // cases, but you do not set the toolbar to act as the action bar. In standalone mode, you\n        // need to manually populate the toolbar with content and actions as follows. Also, the\n        // navigation icon(back arrow) should be handled in setToolbarTitleIcon().\n        binding.toolbarBoardRead.setNavigationOnClickListener(view -> dismiss());\n        tabTitle = getResources().getStringArray(R.array.board_tab_title)[tabPage];\n        autoTitle = ((BoardActivity)requireActivity()).getAutoClubTitle();\n\n        //setHasOptionsMenu(true);\n        // If the user is the owner of a post, display the edit menu in the toolbar, which should\n        // use MenuInflater and create menu dynimically. It seems onCreateOptionsMenu does not work\n        // in DialogFragment\n        if(obj.getUserId() != null && obj.getUserId().equals(viewerId)) {\n            //createEditOptionsMenu();\n            binding.toolbarBoardRead.inflateMenu(R.menu.options_board_read);\n            binding.toolbarBoardRead.setOnMenuItemClickListener(this);\n        }\n\n\n        binding.tvPostTitle.setText(obj.getPostTitle());\n        binding.tvUsername.setText(obj.getUserName());\n        binding.tvPostingDate.setText(requireArguments().getString(\"timestamp\"));\n        binding.tvCntComment.setText(String.valueOf(cntComment));\n        binding.tvCntCompathy.setText(String.valueOf(cntCompathy));\n\n        // Retreive the auto data from the server and set it to the view\n        // UPADTE THE FIRESTORE FIELD NAMES REQUIRED !!\n        //showUserAutoClub(binding.tvAutoinfo);\n\n        // RecyclerView for showing comments\n        LinearLayoutManager layout = new LinearLayoutManager(getContext(), LinearLayoutManager.VERTICAL, false);\n        RecyclerDividerUtil divider = new RecyclerDividerUtil(Constants.DIVIDER_HEIGHT_POSTINGBOARD,\n                0, ContextCompat.getColor(requireContext(), R.color.recyclerDivider));\n        binding.recyclerComments.setHasFixedSize(false); //due to banner plugin\n        binding.recyclerComments.setLayoutManager(layout);\n        binding.recyclerComments.addItemDecoration(divider);\n        binding.recyclerComments.setItemAnimator(new DefaultItemAnimator());\n        binding.recyclerComments.setAdapter(commentAdapter);\n        //setRecyclerViewScrollListener();\n        //binding.recyclerComments.addOnScrollListener(pagingUtil);\n\n        // Event handler for buttons\n        binding.switchComment.setOnCheckedChangeListener(this);\n        binding.imgbtnComment.setOnClickListener(this);\n        binding.imgbtnLoadComment.setOnClickListener(this);\n        binding.imgbtnCompathy.setOnClickListener(view -> setCompathyCount());\n        binding.imgbtnSendComment.setOnClickListener(this);\n        // Implements the abstract method of AppBarStateChangeListener to be notified of the state\n        // of appbarlayout as it is scrolling, which changes the toolbar title and icon by the\n        // scroling state.\n        binding.appbarBoardRead.addOnOffsetChangedListener(new AppBarStateChangeListener() {\n            @Override\n            public void onStateChanged(AppBarLayout appBarLayout, int state) {\n                setToolbarTitleIcon(state);\n            }\n        });\n\n        // RecyclerView.OnScrollListener() does not work if it is inside (Nested)ScrollView. To make\n        // it listen to scrolling, use the parent scollview listener.\n        /*\n        binding.nestedScrollview.setOnScrollChangeListener((NestedScrollView.OnScrollChangeListener)\n                (v, scrollX, scrollY, oldScrollX, oldScrollY) -> {\n                    if((scrollY >= (binding.recyclerComments.getMeasuredHeight() - v.getMeasuredHeight())\n                            && scrollY > oldScrollY)) {\n                        if(!isLoading) {\n                            isLoading = true;\n                            queryPaginationUtil.setNextPostQuery();\n                        }\n                    }\n                });\n        */\n        // Attach the user image in the header, if any, using Glide. Otherwise, the blank image\n        // is set.\n        userPic = (TextUtils.isEmpty(obj.getUserPic()))? Constants.imgPath + \"ic_user_blank_gray\": obj.getUserPic();\n        int size = Constants.ICON_SIZE_TOOLBAR_USERPIC;\n        imgUtil.applyGlideToImageView(Uri.parse(userPic), binding.imgUserpic, size, size, true);\n\n        // Rearrange the text by paragraphs\n        readContentView(obj.getPostContent());\n\n        return binding.getRoot();\n    }\n\n    @NonNull\n    @Override\n    public Dialog onCreateDialog(Bundle savedInstanceState) {\n        Dialog dialog = super.onCreateDialog(savedInstanceState);\n        dialog.requestWindowFeature(Window.FEATURE_NO_TITLE);\n        return dialog;\n    }\n\n    @Override\n    public void onViewCreated(@NonNull View view, Bundle savedInstanceState) {\n        super.onViewCreated(view, savedInstanceState);\n        sharedModel = new ViewModelProvider(requireActivity()).get(FragmentSharedModel.class);\n        imgViewModel = new ViewModelProvider(requireActivity()).get(ImageViewModel.class);\n\n        // SET THE USER IMAGE ICON\n        // ImageViewModel receives a drawable as LiveData from ApplyImageResourceUtil.applyGlideToDrawable()\n        // in which Glide creates the custom target that translates an image fitting to a given\n        // size and returns a drawable.\n        imgViewModel.getGlideDrawableTarget().observe(this, drawable -> {\n            binding.toolbarBoardRead.setLogo(drawable);\n            binding.toolbarBoardRead.setContentInsetStartWithNavigation(0);\n        });\n\n        // If a post is the user's own one, the delete button appears on the toolbar. When tapping the\n        // button and picking the confirm button, FragmentSharedModel.getPostRemoved() notifies\n        // BoardPagerFragment that the user has deleted the post w/ the item position. To prevent\n        // the model from automatically invoking the method, initially set the value to false;\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n        /*\n        // Realtime update of the comment count and compathy count using SnapshotListener.\n        // MetadataChanges.hasPendingWrite metadata.hasPendingWrites property that indicates\n        // whether the document has local changes that haven't been written to the backend yet.\n        // This property may determine the source of events\n        regListener = postRef.addSnapshotListener(MetadataChanges.INCLUDE, (snapshot, e) -> {\n            if(e != null) return;\n            if(snapshot != null && snapshot.exists()) {\n                long cntComment = Objects.requireNonNull(snapshot.getLong(\"cnt_comment\"));\n                long cntCompathy = Objects.requireNonNull(snapshot.getLong(\"cnt_compathy\"));\n                //binding.tvCntComment.setText(String.valueOf(cntComment));\n                //binding.tvCntCompathy.setText(String.valueOf(cntCompathy));\n                //binding.headerCommentCnt.setText(String.valueOf(cntComment));\n            }\n        });\n\n         */\n    }\n\n    @Override\n    public void onPause() {\n        log.i(\"onPause\");\n        super.onPause();\n    }\n\n    @Override\n    public void onDismiss(@NonNull DialogInterface dialog) {\n        log.i(\"onDismiss\");\n        super.onDismiss(dialog);\n    }\n\n    @Override\n    public boolean onMenuItemClick(MenuItem menuItem) {\n        log.i(\"MenuItem clicked: %s\", menuItem);\n        if(menuItem.getItemId() == R.id.action_board_edit) {\n            BoardEditFragment editFragment = new BoardEditFragment();\n            Bundle editBundle = new Bundle();\n            editBundle.putString(\"documentId\", documentId);\n            editBundle.putString(\"postTitle\", obj.getPostTitle());\n            editBundle.putString(\"postContent\", obj.getPostContent());\n            editBundle.putInt(\"position\", position);\n            if (uriStringList != null && uriStringList.size() > 0) {\n                editBundle.putStringArrayList(\"uriImgList\", uriStringList);\n            }\n\n            if(autofilter != null && autofilter.size() > 0){\n                editBundle.putStringArrayList(\"autofilter\", autofilter);\n            }\n\n            editFragment.setArguments(editBundle);\n            requireActivity().getSupportFragmentManager().beginTransaction()\n                    .addToBackStack(null)\n                    .replace(android.R.id.content, editFragment)\n                    .commit();\n            dismiss();\n            return true;\n\n        } else if(menuItem.getItemId() == R.id.action_board_delete) {\n            String title = getString(R.string.board_alert_delete);\n            String msg = getString(R.string.board_alert_msg);\n\n            DialogFragment fragment = CustomDialogFragment.newInstance(title, msg, Constants.BOARD);\n            FragmentManager fragmentManager = getChildFragmentManager();\n\n            fragmentManager.setFragmentResultListener(\"confirmDelete\", fragment, (req, res) -> {\n                if(req.matches(\"confirmDelete\") && (res.getBoolean(\"confirmed\"))) {\n                    postRef.delete().addOnSuccessListener(aVoid -> {\n                        log.i(\"confirmed to delete\");\n                        sharedModel.getRemovedPosting().setValue(position);\n                        dismiss();\n                    }).addOnFailureListener(Throwable::printStackTrace);\n                }\n            });\n\n            fragment.show(fragmentManager, \"alert\");\n            return true;\n        }\n\n        return false;\n    }\n\n\n    @Override\n    public void onCheckedChanged(CompoundButton compoundButton, boolean isChecked) {\n        if(isChecked) {\n            //queryPaginationUtil.setCommentQuery(postRef);\n            log.i(\"comment list:%s\", commentShotList.size());\n            binding.recyclerComments.setVisibility(View.VISIBLE);\n            int visible = (cntComment > PAGING_COMMENT) ? View.VISIBLE : View.GONE;\n            binding.imgbtnLoadComment.setVisibility(visible);\n            //if(cntComment > PAGING_COMMENT) binding.imgbtnLoadComment.setVisibility(View.VISIBLE);\n            //else binding.imgbtnLoadComment.setVisibility(View.GONE);\n\n        } else {\n            //commentAdapter.notifyItemRangeRemoved(0, commentShotList.size());\n            //commentShotList.clear();\n            binding.recyclerComments.setVisibility(View.GONE);\n            //binding.nestedScrollview.post(() -> binding.nestedScrollview.fullScroll(View.FOCUS_UP));\n        }\n    }\n\n    @Override\n    public void onClick(View v) {\n        if(v.getId() == R.id.imgbtn_comment) {\n            // Check whether a user name is set. Otherwise, show an messagie in the snackbar to\n            // move to SettingPrefActivity to make a user name.\n            if(checkUserName()) {\n                int visibility = isCommentVisible ? View.GONE : View.VISIBLE;\n                //int direction = isCommentVisible ? View.FOCUS_UP : View.FOCUS_DOWN;\n                binding.constraintComment.setVisibility(visibility);\n                binding.etComment.getText().clear();\n\n                if(!isCommentVisible) {\n                    binding.etComment.requestFocus();\n                    commentAdapter.notifyItemChanged(checkedPos, true);\n                }\n                isCommentVisible = !isCommentVisible;\n            }\n\n        } else if(v.getId() == R.id.imgbtn_send_comment) {\n            if(TextUtils.isEmpty(binding.etComment.getText())) {\n                Snackbar.make(binding.getRoot(), getString(R.string.board_msg_no_comment), Snackbar.LENGTH_SHORT).show();\n            } else uploadComment();\n\n        } else if(v.getId() == R.id.imgbtn_load_comment) {\n            log.i(\"add more comments\");\n            if(cntComment > commentAdapter.getItemCount()) queryPaginationUtil.setNextCommentQuery();\n            else notifyNoData();\n        }\n    }\n\n    // Implement QueryPostPaginationUtil.OnQueryPaginationCallback overriding the follwoing methods\n    // to show comments on the post by the pagination.\n    @Override\n    public void getFirstQueryResult(QuerySnapshot commentShots) {\n        commentShotList.clear();\n        for(DocumentSnapshot comment : commentShots) commentShotList.add(comment);\n        commentAdapter.notifyItemRangeChanged(0, commentShots.size());\n        //binding.nestedScrollview.post(() -> binding.nestedScrollview.fullScroll(View.FOCUS_DOWN));\n        int scrollY = binding.nestedScrollview.getHeight();\n        binding.nestedScrollview.post(() -> binding.nestedScrollview.smoothScrollTo(0, scrollY, 1000));\n    }\n\n    @Override\n    public void getNextQueryResult(QuerySnapshot nextShots) {\n        final int start = commentShotList.size();\n        for(DocumentSnapshot comment : nextShots) commentShotList.add(comment);\n        commentAdapter.notifyItemRangeChanged(start, nextShots.size());\n        binding.nestedScrollview.post(() -> binding.nestedScrollview.fullScroll(View.FOCUS_DOWN));\n    }\n\n    @Override\n    public void getLastQueryResult(QuerySnapshot lastShots) {\n        final int start = commentShotList.size();\n        for(DocumentSnapshot comment : lastShots) commentShotList.add(comment);\n        commentAdapter.notifyItemRangeChanged(start, lastShots.size());\n        binding.nestedScrollview.post(() -> binding.nestedScrollview.fullScroll(View.FOCUS_DOWN));\n    }\n\n    @Override\n    public void getRemovedQueryResult(DocumentSnapshot removedDoc) {\n\n    }\n\n    @Override\n    public void getModifiedQueryResult(DocumentSnapshot doc) {\n\n    }\n\n    @Override\n    public void getQueryErrorResult(Exception e) {\n        Toast.makeText(getActivity(), e.getMessage(), Toast.LENGTH_SHORT).show();\n    }\n\n    // The BoardCommentAdapter.CommentAdapterListener interface impelemts the following methods\n    // deleteComment(): may delete a comment as long as the reader is the owner of a comment.\n    // deleteCommentReply(): may delete a reply as long as the reader is the owner of a reply.\n    // addCommentReply(): may add a comment\n    // notifyReplyChecked(): notified of whether the switch button turns on or off.\n    @Override\n    public void deleteComment(DocumentSnapshot doc) {\n        postRef.update(\"cnt_comment\", FieldValue.increment(-1)).addOnSuccessListener(bVoid -> {\n            cntComment --;\n            if(cntComment <= PAGING_COMMENT) binding.imgbtnLoadComment.setVisibility(View.GONE);\n            binding.tvCntComment.setText(String.valueOf(cntComment));\n            binding.headerCommentCnt.setText(String.valueOf(cntComment));\n        }).addOnFailureListener(Throwable::printStackTrace);\n    }\n    @Override\n    public void deleteCommentReply(BoardReplyAdapter replyAdapter, DocumentReference commentRef) {\n        log.i(\"post deletion handling\");\n        //final DocumentReference commentRef = postRef.collection(\"comments\").document(commentId);\n        /*\n        commentRef.collection(\"replies\").document(replyId).delete().addOnCompleteListener(task -> {\n            if(task.isSuccessful()) {\n                commentRef.update(\"cnt_reply\", FieldValue.increment(-1));\n                replyAdapter.notifyItemRemoved(pos);\n            }\n        });\n\n         */\n    }\n\n    @Override\n    public void notifyUploadReplyDone(int pos, boolean isDone) {\n        //log.i(\"upload reply: %s, %s\", pos, isDone);\n        if(imm.isActive()) imm.hideSoftInputFromWindow(binding.getRoot().getWindowToken(), 0);\n\n        String msg = (isDone)?\"uploading reply done\" : \"uploading reply failed\";\n        Snackbar.make(binding.getRoot(), msg, Snackbar.LENGTH_SHORT).show();\n        //commentAdapter.notifyItemChanged(position, false);\n    }\n\n    @Override\n    public void notifyNoData() {\n        Snackbar.make(binding.getRoot(), \"No more replies\", Snackbar.LENGTH_SHORT).show();\n    }\n\n    @Override\n    public void notifySwitchChecked(int checkedPos, int bindingPos) {\n        if(imm.isActive()) imm.hideSoftInputFromWindow(binding.getRoot().getWindowToken(), 0);\n        // Hide the comment edittext if the reply switch turns on.\n        if(binding.etComment.isFocused()) {\n            binding.constraintComment.setVisibility(View.GONE);\n            isCommentVisible = false;\n        }\n        // A new reply switch turns on and another switch should be off.\n        this.checkedPos = bindingPos;\n        if(checkedPos != bindingPos) commentAdapter.notifyItemChanged(checkedPos, true);\n\n        //binding.nestedScrollview.post(() -> binding.nestedScrollview.fullScroll(View.FOCUS_DOWN));\n        int scrollY = binding.nestedScrollview.getHeight();\n        binding.nestedScrollview.post(() -> binding.nestedScrollview.smoothScrollTo(0, scrollY, 1500));\n    }\n\n    @Override\n    public void notifyEditTextFocused(View view) {\n        log.i(\"content edit text focused\");\n        if(!checkUserName()) view.clearFocus();\n        binding.nestedScrollview.post(() -> binding.nestedScrollview.smoothScrollTo(0, view.getBottom()));\n    }\n\n    private void getActivityResultCallback(ActivityResult result) {\n        log.i(\"activity result: %s\", result.getData());\n        if(result.getData() != null) log.i(\"user name:\");\n    }\n\n    // Make up the text-based content and any image attached in ConstraintLayout which is dynamically\n    // created by ConstraintSet. Images should be managed by Glide.\n    // The regular expression makes text and images split with the markup which was inserted when images\n    // were created. While looping the content, split parts of text and image are conntected by\n    // ConstraintSets which are applied to the parent ConstraintLayout.\n    // The recyclerview which displays comments at the bottom should be coordinated according to\n    // whether the content has images or not.\n    private void readContentView(String content) {\n        // When an image is attached as the post writes, the line separator is supposed to put in at\n        // before and after the image. That's why the regex contains the line separator in order to\n        // get the right end position.\n        final String REGEX_MARKUP = \"\\\\[image_\\\\d]\";\n        final Matcher m = Pattern.compile(REGEX_MARKUP).matcher(content);\n        final ConstraintLayout parent = binding.constraintPosting;\n\n        int index = 0;\n        int start = 0;\n        int target;\n        int prevImageId = 0;\n\n        // Create LayoutParams using LinearLayout(RelativeLayout).LayoutParams, not using Constraint\n        // Layout.LayoutParams. WHY?\n        LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(\n                LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT);\n\n        // If the content contains images, which means any markup(s) exists in the content, the content\n        // is split into parts of texts and images and respectively connected to ConstraintSet.\n        while(m.find()) {\n            // Check whether the content starts w/ text or image, which depends on the value of start.\n            String paragraph = content.substring(start, m.start());\n            TextView tv = new TextView(context);\n            tv.setId(View.generateViewId());\n            tv.setText(paragraph);\n            parent.addView(tv, params);\n            target = (start == 0) ? binding.guideline.getId() : prevImageId;\n\n            ConstraintSet tvSet = new ConstraintSet();\n            tvSet.clone(parent);\n            tvSet.connect(tv.getId(), ConstraintSet.START, parent.getId(), ConstraintSet.START, 16);\n            tvSet.connect(tv.getId(), ConstraintSet.END, parent.getId(), ConstraintSet.END, 16);\n            tvSet.connect(tv.getId(), ConstraintSet.TOP, target, ConstraintSet.BOTTOM, 16);\n            tvSet.applyTo(parent);\n\n            ImageView imgView = new ImageView(context);\n            imgView.setId(View.generateViewId());\n            prevImageId = imgView.getId();\n            parent.addView(imgView, params);\n\n            ConstraintSet imgSet = new ConstraintSet();\n            imgSet.clone(parent);\n            imgSet.connect(imgView.getId(), ConstraintSet.START, parent.getId(), ConstraintSet.START, 16);\n            imgSet.connect(imgView.getId(), ConstraintSet.END, parent.getId(), ConstraintSet.END, 16);\n            imgSet.connect(imgView.getId(), ConstraintSet.TOP, tv.getId(), ConstraintSet.BOTTOM, 0);\n            imgSet.applyTo(parent);\n\n            // Consider to apply Glide thumbnail() method.\n            Glide.with(context).asBitmap().load(uriStringList.get(index))\n                    .diskCacheStrategy(DiskCacheStrategy.AUTOMATIC).fitCenter().into(imgView);\n\n            start = m.end();\n            index++;\n        }\n\n        // Coordinate the position b/w the last part, no matter what is imageview or textview in the content,\n        // and the following recyclerview which shows any comment\n        // Simple text w/o any image\n        if(start == 0) {\n            TextView simpleText = new TextView(context);\n            simpleText.setId(View.generateViewId());\n            simpleText.setText(content);\n            parent.addView(simpleText, params);\n\n            ConstraintSet tvSet = new ConstraintSet();\n            tvSet.clone(parent);\n            tvSet.connect(simpleText.getId(), ConstraintSet.START, parent.getId(), ConstraintSet.START, 16);\n            tvSet.connect(simpleText.getId(), ConstraintSet.END, parent.getId(), ConstraintSet.END, 16);\n            tvSet.connect(simpleText.getId(), ConstraintSet.TOP, binding.guideline.getId(), ConstraintSet.BOTTOM, 16);\n            tvSet.connect(binding.headerComment.getId(), ConstraintSet.TOP, simpleText.getId(), ConstraintSet.BOTTOM, 64);\n            //tvSet.connect(binding.recyclerComments.getId(), ConstraintSet.TOP, simpleText.getId(), ConstraintSet.BOTTOM, 16);\n            //tvSet.connect(binding.headerComment.getId(), ConstraintSet.TOP, simpleText.getId(), ConstraintSet.BOTTOM, 0);\n            tvSet.applyTo(parent);\n\n        // Text after an image\n        } else if(start < content.length()) {\n            String lastParagraph = content.substring(start);\n            log.i(\"text after an image: %s\", lastParagraph.length());\n            TextView lastView = new TextView(context);\n            lastView.setId(View.generateViewId());\n            lastView.setText(lastParagraph);\n            parent.addView(lastView, params);\n\n            ConstraintSet tvSet = new ConstraintSet();\n            tvSet.clone(parent);\n            tvSet.connect(lastView.getId(), ConstraintSet.START, parent.getId(), ConstraintSet.START, 16);\n            tvSet.connect(lastView.getId(), ConstraintSet.END, parent.getId(), ConstraintSet.END, 16);\n            tvSet.connect(lastView.getId(), ConstraintSet.TOP, prevImageId, ConstraintSet.BOTTOM, 0);\n            tvSet.connect(binding.headerComment.getId(), ConstraintSet.TOP, lastView.getId(), ConstraintSet.BOTTOM, 64);\n            tvSet.applyTo(parent);\n\n        // No text after the last image\n        } else if(start == content.length()) {\n            log.i(\"image positioned at the last\");\n            ConstraintSet imageSet = new ConstraintSet();\n            imageSet.clone(parent);\n            imageSet.connect(binding.headerComment.getId(), ConstraintSet.TOP, prevImageId, ConstraintSet.BOTTOM, 0);\n            imageSet.applyTo(parent);\n        }\n\n    }\n\n\n\n\n    // This abstract class notifies the state of the appbarlayout by implementing the listener.\n    // The reason that the listener should be implemented first is that the listener notifies every\n    // scrolling changes which keep the view being invalidated. The abstract class may, in turn,\n    // receive changes and only notifies the specified state to the view.\n    abstract class AppBarStateChangeListener implements AppBarLayout.OnOffsetChangedListener {\n        int mCurrentState = STATE_IDLE;\n        @Override\n        public final void onOffsetChanged(AppBarLayout appBarLayout, int verticalOffset) {\n            if (verticalOffset == 0) {\n                if (mCurrentState != STATE_EXPANDED) onStateChanged(appBarLayout, STATE_EXPANDED);\n                mCurrentState = STATE_EXPANDED;\n\n            } else if (Math.abs(verticalOffset) >= appBarLayout.getTotalScrollRange()) {\n                if (mCurrentState != STATE_COLLAPSED) onStateChanged(appBarLayout, STATE_COLLAPSED);\n                mCurrentState = STATE_COLLAPSED;\n\n            } else {\n                if(appbarOffset != verticalOffset) {\n                    appbarOffset = verticalOffset;\n                    onStateChanged(appBarLayout, STATE_IDLE);\n                }\n                mCurrentState = STATE_IDLE;\n            }\n        }\n\n        abstract void onStateChanged(AppBarLayout appBarLayout, int state);\n    }\n\n    // Set the toolbar Icon and title as the appbarlayout is scrolling, which is notified by\n    // AppBarStateChangeListener.\n    private void setToolbarTitleIcon(int state) {\n        SpannableString spannable = new SpannableString(obj.getPostTitle());\n        int size = Math.abs(appbarOffset) / 6;\n        spannable.setSpan(new AbsoluteSizeSpan(size), 0, spannable.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);\n        binding.toolbarBoardRead.setTitle(spannable);\n        switch(state) {\n            case STATE_COLLAPSED:\n                //String userPic = (TextUtils.isEmpty(obj.getUserPic()))? Constants.imgPath + \"ic_user_blank_gray\" : obj.getUserPic();\n                binding.toolbarBoardRead.setNavigationIcon(null);\n                binding.toolbarBoardRead.setTitle(spannable);\n                binding.toolbarBoardRead.setSubtitle(obj.getUserName());\n                imgUtil.applyGlideToDrawable(userPic, Constants.ICON_SIZE_TOOLBAR_USERPIC, imgViewModel);\n                binding.toolbarBoardRead.setOnClickListener(view -> dismiss());\n                break;\n\n            case STATE_EXPANDED:\n                binding.toolbarBoardRead.setNavigationIcon(R.drawable.ic_action_navigation);\n                if(tabPage == AUTOCLUB) binding.toolbarBoardRead.setTitle(autoTitle);\n                else binding.toolbarBoardRead.setTitle(tabTitle);\n                binding.toolbarBoardRead.setSubtitle(\"\");\n                binding.toolbarBoardRead.setLogo(null);\n                break;\n\n            case STATE_IDLE: break;\n\n        }\n    }\n\n    // Method for uploading the comment to Firestore\n    private void uploadComment() {\n        Map<String, Object> comment = new HashMap<>();\n        comment.put(\"cnt_reply\", 0);\n        comment.put(\"comment\", binding.etComment.getText().toString());\n        comment.put(\"timestamp\", FieldValue.serverTimestamp());\n        // Fetch the comment user id saved in the storage\n        try(FileInputStream fis = requireActivity().openFileInput(\"userId\");\n            BufferedReader br = new BufferedReader(new InputStreamReader(fis))){\n            String commentId =  br.readLine();\n            comment.put(\"user_id\", commentId);\n            final DocumentReference docref = mDB.collection(\"users\").document(commentId);\n            mDB.runTransaction((Transaction.Function<Void>) transaction -> {\n                DocumentSnapshot doc = transaction.get(docref);\n                comment.put(\"user_name\", doc.getString(\"user_name\"));\n                comment.put(\"user_pic\", doc.getString(\"user_pic\"));\n\n                postRef.collection(\"comments\").add(comment).addOnSuccessListener(commentRef -> {\n                    //queryPaginationUtil.setCommentQuery(postRef, \"timestamp\");\n                    commentRef.get().addOnSuccessListener(snapshot -> {\n                        commentShotList.add(0, snapshot);\n                        commentAdapter.notifyItemInserted(0);\n                    });\n\n                    postRef.update(\"cnt_comment\", FieldValue.increment(1)).addOnSuccessListener(aVoid->{\n                        cntComment++;\n                        binding.tvCntComment.setText(String.valueOf(cntComment));\n                        binding.headerCommentCnt.setText(String.valueOf(cntComment));\n                    });\n\n                    binding.nestedScrollview.fullScroll(View.FOCUS_UP);\n\n                }).addOnFailureListener(Throwable::printStackTrace);\n\n                imm.hideSoftInputFromWindow(binding.getRoot().getWindowToken(), 0);\n                // Make the comment view invisible and reset the flag.\n                binding.constraintComment.setVisibility(View.GONE);\n                isCommentVisible = !isCommentVisible;\n                return null;\n            });\n\n        } catch(IOException | NullPointerException e) {e.printStackTrace();}\n\n    }\n\n    // Check if the user has already picked a post as favorite doing queries the compathy collection,\n    // documents of which contains user ids\n    private void setCompathyCount() {\n        // Prevent repeated connection to Firestore every time when users click the button.\n        final String msg = getString(R.string.board_msg_compathy);\n        if(hasCompathy) {\n            Snackbar.make(binding.getRoot(), msg, Snackbar.LENGTH_SHORT).show();\n            return;\n        }\n\n        final DocumentReference compathyRef = postRef.collection(\"compathy\").document(viewerId);\n        compathyRef.get().addOnCompleteListener(task -> {\n            if(task.isSuccessful()) {\n                DocumentSnapshot snapshot = task.getResult();\n                if(snapshot != null && snapshot.exists()) {\n                    hasCompathy = true;\n                    Snackbar.make(binding.getRoot(), msg, Snackbar.LENGTH_SHORT).show();\n                } else {\n                    postRef.update(\"cnt_compathy\", FieldValue.increment(1)).addOnSuccessListener(aVoid -> {\n                        Map<String, Object> data = new HashMap<>();\n                        data.put(\"timestamp\", FieldValue.serverTimestamp());\n                        compathyRef.set(data);\n                        cntCompathy++;\n                        binding.tvCntCompathy.setText(String.valueOf(cntCompathy));\n\n                    });\n                }\n            }\n        });\n    }\n\n    // As long as a post belongs to the user, show the menu in the toolbar which enables the user\n    // to edits or delete the post.\n\n\n    // Display the auto club if the user has set the automaker, automodel, enginetype, and autoyear.\n    /*\n    private void showUserAutoClub(final TextView autoInfo) {\n        firestore.collection(\"users\").document(postOwnerId).get().addOnCompleteListener(task -> {\n            if(task.isSuccessful()) {\n                DocumentSnapshot document = task.getResult();\n                if(document != null && document.exists()) {\n                    String jsonAutoInfo = document.getString(\"user_club\");\n                    try {\n                        JSONArray json = new JSONArray(jsonAutoInfo);\n                        if(json.length() == 0) return;\n\n                        StringBuilder sb = new StringBuilder();\n                        for(int i = 0; i < json.length(); i++) {\n                            if(json.optString(i) != null && !json.optString(i).equalsIgnoreCase(\"null\")) {\n                                sb.append(json.optString(i)).append(\" \");\n                            }\n                        }\n                        autoInfo.setText(sb.toString());\n                    } catch(JSONException | NullPointerException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        });\n    }\n\n     */\n\n    /*\n    private void queryCommentSnapshot(DocumentReference docref) {\n        postRepo.setCommentQuery(docref);\n        PostingBoardLiveData postLiveData = postingModel.getPostingBoardLiveData();\n        if(postLiveData != null) {\n            postLiveData.observe(getViewLifecycleOwner(), operation -> {\n                int type = operation.getType();\n                DocumentSnapshot postshot = operation.getDocumentSnapshot();\n                switch(type) {\n                    case 0: // ADDED\n                        commentShotList.add(postshot);\n                        break;\n\n                    case 1: // MODIFIED\n                        log.i(\"MODIFIED\");\n                        for(int i = 0; i < commentShotList.size(); i++) {\n                            DocumentSnapshot snapshot = commentShotList.get(i);\n                            if(snapshot.getId().equals(postshot.getId())) {\n                                commentShotList.remove(snapshot);\n                                commentShotList.add(i, postshot);\n                            }\n                        }\n                        break;\n\n                    case 2: // REMOVED\n                        for(int i = 0; i < commentShotList.size(); i++) {\n                            DocumentSnapshot snapshot = commentShotList.get(i);\n                            if(snapshot.getId().equals(postshot.getId())) commentShotList.remove(snapshot);\n                        }\n                        break;\n                }\n\n                commentAdapter.notifyDataSetChanged();\n\n            });\n        }\n    }\n     */\n\n    private boolean checkUserName() {\n        String userName = mSettings.getString(Constants.USER_NAME, null);\n        if (TextUtils.isEmpty(userName)) {\n            Snackbar snackbar = Snackbar.make(binding.getRoot(),\n                    getString(R.string.board_msg_username), Snackbar.LENGTH_LONG);\n\n            snackbar.setAction(R.string.board_msg_action_setting, view -> {\n                Intent intent = new Intent(getActivity(), SettingActivity.class);\n                intent.putExtra(\"postingboard\", Constants.REQUEST_BOARD_SETTING_USERNAME);\n                activityResultLauncher.launch(intent);\n            }).show();\n            return false;\n        } else return true;\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/silverback/carman/fragments/BoardReadFragment.java b/app/src/main/java/com/silverback/carman/fragments/BoardReadFragment.java
--- a/app/src/main/java/com/silverback/carman/fragments/BoardReadFragment.java	
+++ b/app/src/main/java/com/silverback/carman/fragments/BoardReadFragment.java	
@@ -216,14 +216,14 @@
         // the listener to prevent connecting to the server. Instead`, update the collection using
         // Source.Cache.
         postRef = mDB.collection("user_post").document(documentId);
-        queryPaginationUtil.setCommentQuery(postRef, "timestamp");
+        //queryPaginationUtil.setCommentQuery(postRef, "timestamp");
     }
 
     @Override
     public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container,
                              Bundle savedInstanceState) {
 
-        binding = FragmentBoardReadBinding.inflate(inflater);
+        binding = FragmentBoardReadBinding.inflate(inflater, container, false);
         // Set the stand-alone toolabr which works in the same way that the action bar does in most
         // cases, but you do not set the toolbar to act as the action bar. In standalone mode, you
         // need to manually populate the toolbar with content and actions as follows. Also, the
@@ -364,12 +364,21 @@
         super.onPause();
     }
 
+    /*
     @Override
     public void onDismiss(@NonNull DialogInterface dialog) {
         log.i("onDismiss");
         super.onDismiss(dialog);
     }
 
+     */
+
+    @Override
+    public void onDestroyView() {
+        super.onDestroyView();
+        binding = null;
+    }
+
     @Override
     public boolean onMenuItemClick(MenuItem menuItem) {
         log.i("MenuItem clicked: %s", menuItem);
@@ -424,13 +433,13 @@
     @Override
     public void onCheckedChanged(CompoundButton compoundButton, boolean isChecked) {
         if(isChecked) {
-            //queryPaginationUtil.setCommentQuery(postRef);
             log.i("comment list:%s", commentShotList.size());
             binding.recyclerComments.setVisibility(View.VISIBLE);
             int visible = (cntComment > PAGING_COMMENT) ? View.VISIBLE : View.GONE;
             binding.imgbtnLoadComment.setVisibility(visible);
             //if(cntComment > PAGING_COMMENT) binding.imgbtnLoadComment.setVisibility(View.VISIBLE);
             //else binding.imgbtnLoadComment.setVisibility(View.GONE);
+            queryPaginationUtil.setCommentQuery(postRef, "timestamp");
 
         } else {
             //commentAdapter.notifyItemRangeRemoved(0, commentShotList.size());
@@ -498,15 +507,6 @@
         binding.nestedScrollview.post(() -> binding.nestedScrollview.fullScroll(View.FOCUS_DOWN));
     }
 
-    @Override
-    public void getRemovedQueryResult(DocumentSnapshot removedDoc) {
-
-    }
-
-    @Override
-    public void getModifiedQueryResult(DocumentSnapshot doc) {
-
-    }
 
     @Override
     public void getQueryErrorResult(Exception e) {
Index: build.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Top-level build file where you can add configuration options common to all sub-projects/modules.\n\nbuildscript {\n    repositories {\n        google()\n        //jcenter()\n        mavenCentral()\n        \n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:7.1.2'\n        classpath 'com.google.gms:google-services:4.3.10'\n        // NOTE: Do not place your application dependencies here; they belong\n        // in the individual module build.gradle files\n    }\n}\n\nallprojects {\n    repositories {\n        google()\n        //jcenter()\n        mavenCentral()\n        //maven { url 'http://devrepo.kakao.com:8088/nexus/content/groups/public/' }\n        // Namver map sdk.\n        maven { url 'https://naver.jfrog.io/artifactory/maven/' }\n    }\n\n}\n\n// Kakao\n/*\nsubprojects {\n    repositories {\n        mavenCentral()\n        maven { url 'http://devrepo.kakao.com:8088/nexus/content/groups/public/' }\n    }\n}\n*/\n\ntask clean(type: Delete) {\n    delete rootProject.buildDir\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/build.gradle b/build.gradle
--- a/build.gradle	
+++ b/build.gradle	
@@ -8,7 +8,7 @@
         
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:7.1.2'
+        classpath 'com.android.tools.build:gradle:7.1.3'
         classpath 'com.google.gms:google-services:4.3.10'
         // NOTE: Do not place your application dependencies here; they belong
         // in the individual module build.gradle files

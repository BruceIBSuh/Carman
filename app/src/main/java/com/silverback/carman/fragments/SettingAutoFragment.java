package com.silverback.carman.fragments;import static com.silverback.carman.SettingActivity.PREF_AUTOMAKER;import static com.silverback.carman.SettingActivity.PREF_AUTOMODEL;import static com.silverback.carman.SettingActivity.PREF_AUTOTYPE;import static com.silverback.carman.SettingActivity.PREF_AUTOYEAR;import static com.silverback.carman.SettingActivity.PREF_ENGINETYPE;import android.app.Dialog;import android.os.Bundle;import android.text.TextUtils;import android.view.MenuItem;import androidx.annotation.NonNull;import androidx.appcompat.app.AlertDialog;import androidx.fragment.app.DialogFragment;import androidx.lifecycle.ViewModelProvider;import androidx.preference.ListPreference;import androidx.preference.Preference;import androidx.preference.PreferenceManager;import com.google.firebase.firestore.DocumentReference;import com.google.firebase.firestore.DocumentSnapshot;import com.google.firebase.firestore.FieldPath;import com.google.firebase.firestore.FieldValue;import com.google.firebase.firestore.FirebaseFirestore;import com.google.firebase.firestore.Query;import com.google.firebase.firestore.QueryDocumentSnapshot;import com.silverback.carman.R;import com.silverback.carman.logs.LoggingHelper;import com.silverback.carman.logs.LoggingHelperFactory;import com.silverback.carman.utils.Constants;import com.silverback.carman.viewmodels.FragmentSharedModel;import org.json.JSONArray;import java.util.ArrayList;import java.util.Calendar;import java.util.List;import java.util.Map;import java.util.Objects;/* * This fragment is a split screen PreferenceFragmentCompat which displays multiple preferences * on a separate screen with its own preference hierarchy that is concerned with the auto data. * Firestore holds comprehensive data to download but special care is required for latency. */public class SettingAutoFragment extends SettingBaseFragment implements        Preference.OnPreferenceChangeListener {    private static final LoggingHelper log = LoggingHelperFactory.create(SettingAutoFragment.class);    private static final int SINCE = 20;    private FragmentSharedModel fragmentModel;    private ListPreference autoMaker, autoModel, autoType, engineType, autoYear;    private EngineDialogFragment engineDialogFragment;    private DocumentSnapshot makershot, modelshot;    private boolean isMakerChanged, isModelChanged, isAutoTypeChanged, isEngineTypeChanged;    public interface UpdateFieldListener {        void notifyUpdateComplete();    }    // Constructor    public SettingAutoFragment() {        super();    }    //@SuppressWarnings("ConstantConditions")    @Override    public void onCreatePreferences(Bundle savedInstanceState, String rootKey) {        setPreferencesFromResource(R.xml.autopreference, rootKey);        setHasOptionsMenu(true);// necessary for the options menu feasible in fragment        mSettings = PreferenceManager.getDefaultSharedPreferences(requireActivity());        fragmentModel = new ViewModelProvider(requireActivity()).get(FragmentSharedModel.class);        engineDialogFragment = new EngineDialogFragment(fragmentModel);        autoMaker = findPreference(PREF_AUTOMAKER);        autoType = findPreference(PREF_AUTOTYPE);        engineType = findPreference(PREF_ENGINETYPE);        autoModel = findPreference(PREF_AUTOMODEL);        autoYear = findPreference(PREF_AUTOYEAR);        autoMaker.setOnPreferenceChangeListener(this);        autoType.setOnPreferenceChangeListener(this);        autoModel.setOnPreferenceChangeListener(this);        engineType.setOnPreferenceChangeListener(this);        setAutoMakerEntries();        setAutoYearEntries();    }    // If an automodel has multi engine types, pop up the alert dialog to select which engine type    // to select, the result of which should be passed via the viewmodel livedata. The empty check    // is required to prevent the dialog from initally invoking updateRegField().    // To update the engine type field, as far as the multi engine types are concerned, should be    // handled separately here.    /*    @Override    public void onViewCreated(@NonNull View view, Bundle savedInstanceState) {        super.onViewCreated(view, savedInstanceState);        fragmentModel.getEngineSelected().observe(getViewLifecycleOwner(), engine -> {            if(engineType.findIndexOfValue(engine) > 0) {                engineType.setValue(engine);                updateRegField(engineType, true, null);                setAutoPreferenceSummary(engineType, 0);            } else log.i("initial invoke excluded");        });    }     */    // To make the Up button working in Fragment, it is required to invoke sethasOptionsMenu(true)    // and the return value should be true in onOptionsItemSelected(). The values of each preference    // is translated to List<String>, then converted to JSONString for transferring the json string    // to SettingPerrenceFragment to invalidate the preference summary.    @Override    public boolean onOptionsItemSelected(@NonNull MenuItem item) {        if(item.getItemId() == android.R.id.home) {            //String autodata = convAutoDataToJson();            JSONArray jsonArray = new JSONArray();            ListPreference[] preferences = {autoMaker, autoModel, autoType, engineType, autoYear};            for(ListPreference pref : preferences) jsonArray.put(pref.getValue());            fragmentModel.getAutoData().setValue(jsonArray);            return true;        } else return super.onOptionsItemSelected(item);    }    /*     * Preference.OnPreferenceChangeListener     *     * Interface definition for a callback to be invoked when the value of this Preference has been     * changed by the user and is about to be set and/or persisted. This gives the client a chance     * to prevent setting and/or persisting the value.     *     * updateRegField()  ecreases the reg. number if the existing value is valid, then     * the callback calls qeryAutoMaker() to get the model entries if a new value is     * valid and increase the reg number. Otherwise, simply update the UI's.     *     * @param preference: the changed preference     * @param value: the new value of the preference     * @return true to update the state of the preference w/ the new value.     */    @Override    public boolean onPreferenceChange(@NonNull Preference preference, Object value) {        String newValue = (String)value;        // Prevent repeating click on the same pref.        if(newValue.equals(((ListPreference)preference).getValue())) return false;        switch(preference.getKey()) {            case PREF_AUTOMAKER:                isMakerChanged = true;                if(autoMaker.findIndexOfValue(autoMaker.getValue()) > 0) {                    updateRegField(autoMaker, false, () -> {                        if(autoMaker.findIndexOfValue(newValue) > 0) queryAutoMaker(newValue);                        else {                            autoMaker.setValueIndex(0);                            autoMaker.setValue(null);                            setAutoPreferenceSummary(autoMaker, 0);                            ListPreference[] arrPrefs = {autoModel, autoType, engineType, autoYear};                            for(ListPreference pref : arrPrefs) pref.setEnabled(false);                        }                    });                } else queryAutoMaker(newValue);                return true;            case PREF_AUTOTYPE:                isAutoTypeChanged = true;                if(autoModel.findIndexOfValue(autoModel.getValue()) > 0) {                    updateRegField(autoModel, false, () -> {                        if(autoType.findIndexOfValue(newValue) > 0){                            setAutoModelEntries(newValue, engineType.getValue());                        } else {                            autoType.setValueIndex(0);                            autoType.setValue(null);                            setAutoPreferenceSummary(autoType, 0);                        }                    });                } setAutoModelEntries(newValue, engineType.getValue());                return true;            case Constants.ENGINE_TYPE:                isEngineTypeChanged = true;                if(autoModel.findIndexOfValue(autoModel.getValue()) > 0) {                    updateRegField(autoModel, false, () -> {                        if(engineType.findIndexOfValue(engineType.getValue()) > 0) {                            setAutoModelEntries(autoType.getValue(), newValue);                        } else {                            engineType.setValueIndex(0);                            engineType.setValue(null);                            setAutoPreferenceSummary(engineType, 0);                        }                    });                } else setAutoModelEntries(autoType.getValue(), newValue);                return true;            case PREF_AUTOMODEL:                isModelChanged = true;                log.i("automodel changed: %s", autoModel.getValue());                if(autoModel.findIndexOfValue(autoModel.getValue()) > 0) {                    updateRegField(autoModel, false, () -> {                        if(autoModel.findIndexOfValue(newValue) > 0)                            queryAutoModel(autoMaker.getValue(), newValue);                        else {                            ListPreference[] arrPrefs = {autoModel, autoType, engineType, autoYear};                            for(ListPreference pref : arrPrefs) {                                pref.setValueIndex(0);                                pref.setValue(null);                                setAutoPreferenceSummary(pref, 0);                            }                        }                    });                } else queryAutoModel(autoMaker.getValue(), newValue);                return true;            default: return false;        }    }    // Implement the abstract method defined in SettingBaseFragment to    //@SuppressWarnings({"ConstantConditions", "unchecked"})    @Override    public void queryAutoMakerSnapshot(DocumentSnapshot makershot) {        this.makershot = makershot;        log.i("queryAutoMakerSnapshot: %s", makershot.getId());        // Retrieve the auto_type and engine_type fields as Map object, typecasting them to        // ArrayList and String arrays.        String typeValue = autoType.getValue();        String engineValue = engineType.getValue();        ObjectAutoData dataList = makershot.toObject(ObjectAutoData.class);        if(makershot.get("auto_type") != null) {            Map<String, Integer> autotypeMap = Objects.requireNonNull(dataList).getAutoTypeMap();            List<String> autotypeList = new ArrayList<>(autotypeMap.keySet());            autotypeList.add(0, getString(R.string.pref_entry_void));            String[] arrAutotype = autotypeList.toArray(new String[0]);            autoType.setEntries(arrAutotype);            autoType.setEntryValues(arrAutotype);            if(!autoType.isEnabled()) {                autoType.setEnabled(true);                setAutoPreferenceSummary(autoType, 0);            }        }        // Set the enes to the engineType preference        if(makershot.get("engine_type") != null) {            Map<String, Integer> enginetypeMap = Objects.requireNonNull(dataList).getEngineTypeMap();            List<String> enginetypeList = new ArrayList<>(enginetypeMap.keySet());            enginetypeList.add(0, getString(R.string.pref_entry_void));            String[] arrEngineType = enginetypeList.toArray(new String[0]);            engineType.setEntries(arrEngineType);            engineType.setEntryValues(arrEngineType);            if(!engineType.isEnabled()) {                engineType.setEnabled(true);                setAutoPreferenceSummary(engineType, 0);            }        }        if(!autoYear.isEnabled()) autoYear.setEnabled(true);        setAutoPreferenceSummary(autoYear, 0);        // Set the automodel entries(entryValues). In this case, the params should be null, which        // means no conditioned query will be made.        if(!autoModel.isEnabled()) autoModel.setEnabled(true);        setAutoPreferenceSummary(autoModel, 0);        setAutoModelEntries(typeValue, engineValue);        // Set or update the registration number according to whether the automaker preference        // has changed.        if(isMakerChanged) {            log.i("new maker: %s", autoMaker.getValue());            autoMaker.setValue(makershot.getId());            updateRegField(autoMaker, true, null);        } else {            int num = Objects.requireNonNull(makershot.getLong("reg_maker")).intValue();            setAutoPreferenceSummary(autoMaker, num);        }    }    //@SuppressWarnings({"ConstantConditions", "unchecked"})    @Override    public void queryAutoModelSnapshot(DocumentSnapshot modelshot) {        this.modelshot = modelshot;        // Set the autotype preference value based upon a queried automodel.        final String autotype = modelshot.getString("model_type");        if(!TextUtils.isEmpty(autotype)) autoType.setValue(autotype);        else setAutoPreferenceSummary(autoType, 0);        // Set the enginetype preference value. As far as the user changes the model which has        // multiple engine types, pop up the dialog to select which engine type to select and        // send the result via the viewmodel livedata to separately update the field.        if(isModelChanged) {            autoModel.setValue(modelshot.getId());            ArrayAutoData autodata = modelshot.toObject(ArrayAutoData.class);            List<String> engineList = Objects.requireNonNull(autodata).getEngineTypeList();            if(engineList.size() > 1) {                String[] arrType = engineList.toArray(new String[0]);                engineDialogFragment.setEngineTypes(arrType);                engineDialogFragment.show(getChildFragmentManager(), "engineFragment");                fragmentModel.getEngineSelected().observe(getViewLifecycleOwner(), engine -> {                    engineType.setValue(engine);                    updateRegField(autoModel, true, null);                });            } else {                engineType.setValue(engineList.get(0));                updateRegField(autoModel, true, null);            }        } else {            int num = Objects.requireNonNull(modelshot.getLong("reg_model")).intValue();            setAutoPreferenceSummary(autoModel, num);            setAutoPreferenceSummary(autoType, 0);            setAutoPreferenceSummary(engineType, 0);            setAutoPreferenceSummary(autoYear, 0);        }    }    // Query the auto makers from firestore and set the entries to the autoMaker preference.    private void setAutoMakerEntries() {        autoRef.get().addOnSuccessListener(queries -> {            List<String> autoMakerList = new ArrayList<>();            autoMakerList.add(0, getString(R.string.pref_entry_void));            for(QueryDocumentSnapshot snapshot : queries) autoMakerList.add(snapshot.getId());            autoMaker.setEntries(autoMakerList.toArray(new CharSequence[0]));            autoMaker.setEntryValues(autoMakerList.toArray(new CharSequence[0]));            if(autoMaker.findIndexOfValue(autoMaker.getValue()) > 0) {                queryAutoMaker(autoMaker.getValue());            } else {                // Initialize the dependent auto preferences.                ListPreference[] arrPrefs = {autoMaker, autoType, engineType, autoModel, autoYear};                for(ListPreference pref : arrPrefs) {                    setAutoPreferenceSummary(pref, 0);                    //pref.setValueIndex(0);                    pref.setValue(null);                }            }        });    }    // This method queries auto models with automaker and autotypes as conditions. The auto maker    // is required but the auto types may be null. Special care should be taken when async    // queries are made. This method takes Continuation which queries auto maker first. On completion,    // the next query is made with the integer value of auto type, which may be null.    private void setAutoModelEntries(String autotype, String enginetype) {        List<String> automodelList = new ArrayList<>();        automodelList.add(0, getString(R.string.pref_entry_void));        Query query = makershot.getReference().collection("automodels");        if(autoType.findIndexOfValue(autotype) > 0) {            query = query.whereEqualTo("model_type", autotype);        }        if(engineType.findIndexOfValue(enginetype) > 0) {            query = query.whereArrayContains("model_engine", enginetype);        }        query.get().addOnSuccessListener(queries -> {            for(QueryDocumentSnapshot modelshot : queries) automodelList.add(modelshot.getId());            autoModel.setEntries(automodelList.toArray(new String[0]));            autoModel.setEntryValues(automodelList.toArray(new String[0]));            if(autoModel.findIndexOfValue(autoModel.getValue()) > 0) {                log.i("init query automodel:%s", autoModel.getValue());                queryAutoModel(makershot.getId(), autoModel.getValue());            }            if(isAutoTypeChanged || isEngineTypeChanged) {                setAutoPreferenceSummary(autoModel, 0);                autoModel.setValue(null);                isAutoTypeChanged = false;                isEngineTypeChanged = false;            }        });    }    // Create the year list and set the entries to the autoYear preference.    private void setAutoYearEntries() {        List<String> yearList = new ArrayList<>();        yearList.add(0, getString(R.string.pref_entry_void));        int year = Calendar.getInstance().get(Calendar.YEAR);        for (int i = year + 1; i >= ((year + 1) - SINCE); i--) yearList.add(String.valueOf(i));        CharSequence[] years = yearList.toArray(new CharSequence[0]); // zero-size array.        autoYear.setEntries(years);        autoYear.setEntryValues(years);    }    /*     * Update the related autodata fields when the user changes the current auto maker or model.     * @param pref changed preference     * @param isIncrement increment or decrement the related field vlaue.     *     * Sync issue that the isIncrement values(true/false) are not guaranteed which value to come     * first.     *     */    //private void updateRegField(ListPreference pref, String value, boolean isIncrement){    private void updateRegField(ListPreference pref, boolean isIncrement, UpdateFieldListener callback){        int inc = (isIncrement) ? 1 : -1;        final DocumentReference makerRef = autoRef.document(makershot.getId());        if(pref.equals(autoMaker)) {            FirebaseFirestore.getInstance().runTransaction(transaction -> {                transaction.update(makerRef, "reg_maker", FieldValue.increment(inc));                // As the automodel has been set, it is required to update all other auto data                // when the automaker changes.                final String model = autoModel.getValue();                if (autoModel.findIndexOfValue(model) > 0) {                    log.i("automodel isIncrement: %s", isIncrement);                    DocumentReference modelRef = makerRef.collection("automodels").document(model);                    FieldPath regEnginePath = FieldPath.of("reg_engine", engineType.getValue());                    FieldPath engineTypePath = FieldPath.of("engine_type", engineType.getValue());                    FieldPath autoTypePath = FieldPath.of("auto_type", autoType.getValue());                    transaction.update(modelRef, "reg_model", FieldValue.increment(inc));                    transaction.update(modelRef, regEnginePath, FieldValue.increment(inc));                    transaction.update(makerRef, engineTypePath, FieldValue.increment(inc));                    transaction.update(makerRef, autoTypePath, FieldValue.increment(inc));                }                return null;            }).addOnSuccessListener(aVoid -> {                if(isIncrement) {                    makerRef.get().addOnSuccessListener(doc -> {                        int num = Objects.requireNonNull(doc.getLong("reg_maker")).intValue();                        setAutoPreferenceSummary(autoMaker, num);                        isMakerChanged = false;                    });                } else {                    ListPreference[] arrPrefs = {autoModel, autoType, engineType, autoYear};                    for (ListPreference preference : arrPrefs) {                        preference.setValueIndex(0);                        preference.setValue(null);                        setAutoPreferenceSummary(preference, 0);                    }                    Objects.requireNonNull(callback).notifyUpdateComplete();                }            }).addOnFailureListener(e -> log.e("update automaker field failed:%s", e));        } else if(pref.equals(autoModel)) {            DocumentReference modelRef = makerRef.collection("automodels").document(modelshot.getId());            FirebaseFirestore.getInstance().runTransaction(transaction -> {                DocumentSnapshot snapshot = transaction.get(modelRef);                FieldPath autotypePath = FieldPath.of("auto_type", snapshot.getString("model_type"));                FieldPath engineTypePath = FieldPath.of("engine_type", engineType.getValue());                FieldPath regEnginePath = FieldPath.of("reg_engine", engineType.getValue());                transaction.update(modelRef, "reg_model", FieldValue.increment(inc));                transaction.update(makerRef, autotypePath, FieldValue.increment(inc));                transaction.update(makerRef, engineTypePath, FieldValue.increment(inc));                transaction.update(modelRef, regEnginePath, FieldValue.increment(inc));                /*                // In case of either a single engine model or isIncrement set to false.                //if(engineType.findIndexOfValue(engineType.getValue()) > 0) {                if(!isIncrement) {                    //String key = (isIncrement)?engineType.getValue():engine;                    FieldPath engineTypePath = FieldPath.of("engine_type", engineType.getValue());                    FieldPath regEnginePath = FieldPath.of("reg_engine", engineType.getValue());                    transaction.update(makerRef, engineTypePath, FieldValue.increment(inc));                    transaction.update(modelRef, regEnginePath, FieldValue.increment(inc));                }                 */                return null;            }).addOnSuccessListener(aVoid -> {                if(isIncrement) {                    log.i("update complete");                    modelRef.get().addOnSuccessListener(doc -> {                        int num = Objects.requireNonNull(doc.getLong("reg_model")).intValue();                        setAutoPreferenceSummary(autoModel, num);                        isModelChanged = false;                    });                } else {                    ListPreference[] arrPrefs = {autoModel, autoType, engineType, autoYear};                    for (ListPreference preference : arrPrefs) {                        preference.setValueIndex(0);                        preference.setValue(null);                        setAutoPreferenceSummary(preference, 0);                    }                    Objects.requireNonNull(callback).notifyUpdateComplete();                }            }).addOnFailureListener(e -> log.e("update transaction failed: %s", e.getMessage()));        } else if(pref.equals(engineType)) {            final String engine = engineType.getValue();            DocumentReference modelRef = makerRef.collection("automodels").document(modelshot.getId());            FirebaseFirestore.getInstance().runTransaction(transaction -> {                transaction.update(makerRef, FieldPath.of("engine_type", engine), FieldValue.increment(inc));                transaction.update(modelRef, FieldPath.of("reg_engine", engine), FieldValue.increment(inc));                return null;            });        }    }    /* Set the preference summary with the registration number, if available.     * @param preference ListPreference     * @param num: registration number. 0 means not available.     */    private void setAutoPreferenceSummary(ListPreference preference, int num) {        preference.setSummaryProvider(pref -> {            String value = preference.getValue();            String output = (num == 0)? value : value + " [" + num + "]";            return (TextUtils.isEmpty(value))? getString(R.string.pref_entry_void): output;        });    }    /*     * This static inner class creates the alert dialog to select an engine type if the use newly     * selects or changes an model, which contains multiple engine types, the result of which should     * be passed in onViewCreated with a livedata becasue the dialog is defined as static.     */    public static class EngineDialogFragment extends DialogFragment {        private final FragmentSharedModel fragmentModel;        private String[] types;        EngineDialogFragment(FragmentSharedModel model) {            this.fragmentModel = model;        }        @NonNull        @Override        public Dialog onCreateDialog(Bundle savedInstanceState) {            AlertDialog.Builder builder = new AlertDialog.Builder(requireActivity());            builder.setTitle("Engine Type")                    .setItems(types, (dialogInterface, i) -> {                        log.i("dialoginterface:%s", i);                        fragmentModel.getEngineSelected().setValue(types[i]);                    });            return builder.create();        }        void setEngineTypes(String[] types) {            this.types = types;        }    }}